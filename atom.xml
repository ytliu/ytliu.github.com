<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Mctrain's Blog]]></title>
  <link href="http://ytliu.github.com/atom.xml" rel="self"/>
  <link href="http://ytliu.github.com/"/>
  <updated>2013-05-27T11:29:26+08:00</updated>
  <id>http://ytliu.github.com/</id>
  <author>
    <name><![CDATA[Liu Yutao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ChinaSys小记（2013.5）]]></title>
    <link href="http://ytliu.github.com/blog/2013/05/22/chinasysxiao-ji/"/>
    <updated>2013-05-22T19:25:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/05/22/chinasysxiao-ji</id>
    <content type="html"><![CDATA[<p>猛然发现好久没有写博客了，一阵罪恶感袭来，都有点不知道这段日子时间都是怎么过去的了，之前赶CCS失败告终，然后一阵混沌，又去北京参加ChinaSys，和实验室去常州春游，回来继续做我们的project&#8230;甚至连课都好久没去上了，以至于这周是单周还是双周都不知道了，今天的专业英语做presentation也错过了（不过还好有靠谱的队友，不然就悲剧了）。</p>

<p>今天去游泳的路上乃正问我最近有没有学到什么好玩的东西，我脱口而出：最近什么东西都没学。。。现在回头想想真的是这样的，最近好像都没有什么能让我记得住的输入，也没有太多很好的输出，整个人就是一种僵硬的状态，感觉很不好。</p>

<p>不过最近有在看一本李笑来的《把时间当做朋友》，觉得里面作者的好多观点都挺有趣的，之前在看Solidot的时候也猛然发现李笑来是当前中国比特币收藏最多的人（10万比特币，约1%的比特币总量），果然是个不寻常的人啊！</p>

<hr />

<p>好吧，还是尽快进入主题吧，上周四到周六去了一趟北京，参加了第四届ChinaSys，和去年10月在武汉参加的第三届ChinaSys相比，这次由于是在北京，清华、北大、中科院计算所、微软亚研的人去的非常之多，人数达到了空前的上百人之多，而且感觉和上次相比自己这次的收获也会大一些，不过遗憾的是之前认识的几个好友这次由于在赶paper都没去。</p>

<p>下面就以流水账的形式记录下自己能记住的一些东西，以及自己的感受吧。</p>

<!-- more -->


<h4>2013.5.16 周四 中关村</h4>

<p>晚上到达北京燕山大酒店，23点小杜杜还专门骑车从清华跑来看我，抱了一个大西瓜，聊了1个来小时，感觉大家都不容易啊，也感觉很温馨！</p>

<h4>2013.5.17 周五 静之湖</h4>

<p>上午去中科院计算所坐车去了北六环的静之湖，吃了个午饭，和清华和华科的几个博士聊了会儿天，就开始了下午的talk。</p>

<ul>
<li>第一个Keynote是由AMD的<a href="http://www.cse.psu.edu/~yuanxie/">谢源</a>教授来讲，他主要从能源、Hyperscale computing等角度来分析了下当前以及未来的系统设计在体系结构等方面的发展方向，由于我在这个方向不是很熟悉，所以听得也比较模糊。</li>
<li>计算所的刘磊博士介绍了他们在去年PACT&#8217;12做的Memory bank partition之后又在进行的一些研究工作，即将bank partition和cache partition进行结合，还蛮有意思的。</li>
<li>Intel的段建刚工程师这次也来这里介绍了下他自己以及他们团队做的一些事，他们主要是在Intel里面做开源项目的，介绍了下他们一些感兴趣的方向。</li>
<li>北大的陈琪博士介绍了他们的一个云服务平台自动管理的架构，运用了一些比如color set之类的技术，我也没有听的很认真。</li>
<li>这个session我最有印象的是计算所的另一个工作，叫做<em>Distributed Deadline propagation</em>：他们做的叫做“分布式实时约束传播方法”，打个比方就是将北京的公交系统和纽约的进行比较，在北京，如果一辆车遇到一个红灯，它在之后的路口也会有很大的概率遇到红灯，而在纽约则不是这样的，它们运用了信息共享的技术，使得一辆车不会在多个路口同时碰到红灯，保证了一定的公平性。它将这个原理运用到分布式系统的数据流中，并加入了一个deadline参数，使得其在数据的流动过程中进行传递，提高了数据节点内单个节点的性能波动容忍范围，里面还要进行精确时间控制，主要的做法就是提高或者降低数据的优先级。</li>
</ul>


<p>晚上在微软亚研的赞助下吃了一顿自助餐，认识了三个国防科大的博士。</p>

<h4>2013.5.18 周六 静之湖</h4>

<p>上午的session是两个keynote，一个是Baidu的<a href="http://cn.linkedin.com/pub/shiding-lin/4a/a88/1a2">林仕鼎</a>工程师的talk，他演讲的主题叫做“Application-Driven Datacenter Computing”，介绍了他们家在做的面向应用的架构，以及整个搜索引擎的整个流程框架，同时，他还给出了一些蛮有趣的数据，比如在百度，一个做transaction的机器：</p>

<pre><code>数据总量（100~1000PB）
数据处理量（10-100PB/天）
网页（千亿-万亿）
索引（百亿-千亿）
更新量（十亿-百亿/天）
请求（十亿-百亿/天）
日志（100TB-1PB/天）
</code></pre>

<p>第三个keynote是计算所的<a href="http://www.ncic.ac.cn/en/about/about_XuZhiwei.htm">徐志伟</a>教授给的，题目很有趣，叫做“昆虫纲悖论”，他主要提出一个在他看来未来这个领域的发展方向：人端市场像哺乳动物纲，物端市场像昆虫纲。也就是说他认为未来物端（相比于面对人的服务，物端是指那些面对物的电子设备，比如一些传感器之类的）是一个无法估量的大市场，需要开发出足够合适的系统来支持。那天午餐我正好也和徐教授坐在一桌，我当时问他到底他指的物端是指什么，他的回答是：其实我也不清楚，需要你们自己去发现和定义。。。</p>

<p>午餐还和<a href="http://asg.ict.ac.cn/baoyg/">包云冈</a>老师一起聊了会儿天，从去年ChinaSys开始就一直觉得包老师是一个很儒雅的学者，感觉和他说话什么的也非常舒服，另外之前和他的学生聊天，也说他非常的nice，真的蛮喜欢他的。</p>

<p>下午的三个Session，第一个是security and reliability：</p>

<ul>
<li>第一个是微软亚研的<a href="http://research.microsoft.com/en-us/people/zhenyug/">郭振宇</a>，它的talk题目很吸引人，叫做“Failure recovery: when the cure is worse than the disease”，介绍的是他们实际遇到的问题，即发现很多时候一些failure recovery的程序反而会使得更大的系统down掉。</li>
<li>之后是<a href="http://ipads.se.sjtu.edu.cn/doku.php?id=haibo_chen">海波</a>介绍我们的Redroid，这里就不详说了。</li>
</ul>


<p>之后的两个session是power和multicore，现在还记得的只剩两个talk了：</p>

<ul>
<li>一个是计算所<a href="http://www.carch.ac.cn/~yan/home.html">鄢贵海</a>老师的SmartCap，即通过一系列属性得出Android应用的最高频率，并在Android自带的onDemand算法中限制应用所能得到的最高频率。</li>
<li>还有一个是北京理工大学的<a href="http://cs.bit.edu.cn/~pass/">计卫星</a>老师的关于Ruby并行化中对race detection的研究，主要思想是并行任务在运行过程中locally处理读与写，并在聚合的时候检查之前是否存在冲突。</li>
</ul>


<p>然后就坐车回计算所，然后去北京南站坐动车回上海了。。。</p>

<hr />

<p>总的来说，ChinaSys就是中国那些系统方向的大佬们的一次聚会，以及让我们这些不同学校的小博士们进行一些学术交流，或者互相吐吐槽，多认识些人，了解下大家都在做些什么东西。两天的ChinaSys之行还是蛮有趣的，虽然一直在听talk有些疲惫，加上溃疡吃东西也不是很舒服，但是还是很值得的。</p>

<hr />

<p>到上海之后两天就和实验室一起去常州南山和天目湖春游了，爬了两天的山，脚好酸，感觉自己太弱了！最后放一张图作为结束吧（感觉这张照片的构图很不错，最后那个摆出V字形的就是弱弱的我啦啦啦）</p>

<p><img src="http://ytliu.info/images/2013-05-22-1.jpeg" title="IPADS Image" alt="IPADS Image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android的那些事 - CyanogenMod]]></title>
    <link href="http://ytliu.github.com/blog/2013/05/04/androidde-na-xie-shi-cyanogenmod/"/>
    <updated>2013-05-04T22:07:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/05/04/androidde-na-xie-shi-cyanogenmod</id>
    <content type="html"><![CDATA[<p>这个系列我想记录一些和Android相关但是和技术无关的东西，这次就从CyanogenMod开始讲起吧。</p>

<p>今天要把一个源码编译到手机上（我的测试机是Samsung Galaxy Nexus），按照以前的经历，首先要把它<code>lunch</code>成maguro，然后再开始make，但是这次的lunch发现只有一个叫做cm_maguro的选项，而且关键是它说找不到相关的配置文件，而且<code>repo sync</code>也失败了。</p>

<p>讲到这里，我就不想继续下去了，这个就是一个装机的过程，遇到各种错误，然后google，然后。。。这个过程我打算另开一篇，而这一篇是关于这个<strong>cm_maguro</strong>。</p>

<p>明白人都知道，这个“cm”指的就是“CyanogenMod”，而这个maguro呢？据说是Samsung Galaxy Nexus的一个代号而已，名为金枪鱼。这些在我们平时刷ROM的时候经常会出现的字眼，说出来都不好意思，我从来就没有搞清楚过他们之间具体的关系是什么，直到今天，我感觉自己终于有了一点头绪。</p>

<p>先声明下，以下的部分基本上都是从各种百科或者论坛或者wiki再或者是CyanogenMod的官方网站上撸下来之后进行整理的，可能会感觉似曾相识，不过没关系，就当看故事好了。</p>

<hr />

<h4>CyanogenMod</h4>

<p><a href="http://wiki.cyanogenmod.org/w/About">CyanogenMod</a>，从人的角度来说，是一个由Android爱好者组成的团队，并且它是目前全球最大的Android第三方编译团队。而从系统的角度来说，它又是一个基于开源Android系统，供某些手机使用的二级市场固件，它提供了一些在官方Android系统或手机厂商没有提供的功能。</p>

<p>那么为什么会出现CyanogenMod呢？</p>

<p>原因很简单，我们知道Android系统从一开始发布就是一个开源的系统，当时Android有另外一个问题就是，代码是开源了，但是那么多机型Google就算再闲也某赖新菜（方言，表示没心情管它，请无视），就拿Android 2.3来说，Google开放的源码只支持Nexus S和Nexus One，而对于其它机型，比如HTC的xxx，LG的xxx，google只能说一声对不住了。虽然不同的手机制造厂商会花力气下去生产自己的ROM（简单来说，就是能把改过的代码跑在自己的机器上），但是作为一个Android用户，如果他想刷机怎么办？开源的代码不支持自己的机型，支持自己机型的ROM又由生产厂商封锁着，那些说好的“新功能”呢？那些说好的“随意刷机”呢？我觉得可以这么说，如果没有像CyanogenMod这样的团队，现在什么牛逼的第三方ROM，什么MIUI，估计都还在娘胎里没生出来吧，也就更不用说今天Android手机的千秋万代，一统江湖了。</p>

<!-- more -->


<p>那么，CyanogenMod这样的团队到底做了些什么呢？</p>

<p>问得好！其实吧，我也只是一知半解。我只是知道，相比于Google只对少数的几款机型的支持，CyanogenMod增加了对很多其它机型的支持，而这些改动主要是在内核部分。这些内核源代码都是各厂商根据GPL协议共开出来的，CM会在上面作一些改动（比如增加收音机，720P录像等）。</p>

<p>也就是说，CM基于Google官方发布的ASOP，每当google发布新版本的ASOP的时候，CM团队都会将它们port到不同的机型上，并且增加一些新的特性、功能和bug的修复等等。也正是因为这样，CM的ROM经常也会为ASOP带来很多好处，有时候CM加上的新特性会在ASOP的新版本中出现，CM对bug的修复也会贡献给ASOP。</p>

<p>另外在<a href="http://wiki.cyanogenmod.org/index.php?title=Devices">这里</a>可以找到所有CM支持的机型和它们相对应的代号，非常牛逼！</p>

<h5>ROM，firmware，operating system，distribution</h5>

<p>在CM的<a href="http://wiki.cyanogenmod.org/w/About">官方介绍</a>中特别说明，这四个词对于CyanogenMod来说都是指的同一个意思，都是指你装在你手机设备上的一整套软件。</p>

<h5>CM版本</h5>

<p>我们经常会看到CM7，CM8等等，这些都是CM的版本号，从<a href="http://en.wikipedia.org/wiki/CyanogenMod#Version_history">wiki</a>上的一张图可以很清楚的看出这些版本都是代表些什么意思：</p>

<p><img src="http://ytliu.info/images/2013-05-04-1.png" title="CM version" alt="CM version" /></p>

<hr />

<h4>maguro, toro, tuna</h4>

<p>在刷Galaxy Nexus的时候，会碰到这些代号，简单来说，tuna是Samsung Galaxy Nexus的代号，名为金枪鱼（maguro也是金枪鱼的意思）。</p>

<p>这里稍微跑题下，Android的很多机型都是采用和“鱼”相关的代号，比如Galaxy Nexus (tuna, 金枪鱼)，emulator (goldfish, 金鱼)，G1 (trout, 鲑鱼)， Nexus One (mahimahi, 海豚鱼)，Nexus S (herring, 鲱鱼)，Xoom (stingray, 黄貂鱼)等等。</p>

<p>那么maguro和toro又是什么呢？</p>

<p>事实上，Galaxy Nexus有两种类型的设备，一种是GSM/HSPA+的种类，代号为maguro，一种是CDMA/LTE的种类，代号为toro（还有一个它的变种叫toroplus）。对于maguro来说，在Galaxy Nexus的源码树中，一般会有两个目录，一个是<code>device/samsung/tuna</code>，一个是<code>device/samsung/maguro</code>。前者涵盖了所有maguro和toro共享的文件，而后者则存储和maguro特定相关的文件。</p>

<h5>如何识别</h5>

<p>有两种方法，一种是查看<code>Settings &gt; About phone &gt; Model number</code>，看看以下哪个匹配：</p>

<ul>
<li>Samsung Galaxy Nexus (Maguro; GSM/HSPA+) - GT-I9250</li>
<li>Samsung Galaxy Nexus (Toro; Verizon; CDMA/LTE) - SGH-I515</li>
<li>Samsung Galaxy Nexus (Toro Plus; Sprint; CDMA/LTE) - SPH-L700</li>
</ul>


<p>但是在我刷好的手机上，<code>Model number</code>显示的只有Galaxy Nexus，所以可以采用第二种更简单的办法，即看手机后盖上的图标，看看它是否有Verizon (toro) 或者 Sprint (toroplus)字样，如果都没有，那就是maguro了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[系统调用学习笔记 - ptrace和wait]]></title>
    <link href="http://ytliu.github.com/blog/2013/04/30/xi-tong-diao-yong-xue-xi-bi-ji-ptrace/"/>
    <updated>2013-04-30T09:46:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/04/30/xi-tong-diao-yong-xue-xi-bi-ji-ptrace</id>
    <content type="html"><![CDATA[<p>在系统安全这门课上讲到ptrace这个系统调用，我马上想到当年做CFIMon里面用到的ptrace:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">child</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">     * force the task to stop before executing the first</span>
</span><span class='line'><span class="cm">     * user level instruction</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_TRACEME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">......</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">execvp</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arg</span><span class="p">);</span>
</span><span class='line'>    <span class="cm">/* not reached */</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在parent的代码里面：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">     * wait for the child to exec</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="n">ret</span> <span class="o">=</span> <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="n">WUNTRACED</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">WIFEXITED</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
</span><span class='line'>        <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;task %s [%d] exited already status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pid</span><span class="p">,</span> <span class="n">WEXITSTATUS</span><span class="p">(</span><span class="n">status</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">......</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="n">perf_event_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hw</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">buf</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">map_size</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">......</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">     * effectively activate monitoring</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_CONT</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">......</span>
</span></code></pre></td></tr></table></div></figure>


<p>先是waitpid，等待child调用execv，之后设置一系列参数（在这里是打开perf_event，并mmap一段内存区域），然后调用ptrace让child继续执行。</p>

<p>其实到现在为止我也还不是很清楚ptrace的用法和waitpid那几个参数的意思，于是想好好学习下，在google上搜到了一篇翻译的<a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_i/">玩转ptrace1</a>和<a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_ii/">2</a>，这里归纳整理下，另外，在IBM的<a href="https://www.ibm.com/developerworks/cn/">developerWorks</a>上找到一篇介绍进程相关，以及waitpid的<a href="http://www.ibm.com/developerworks/cn/linux/kernel/syscall/part3/">博文</a>，也一起学习了。</p>

<!-- more -->


<hr />

<h3>僵尸进程和wait</h3>

<p>在linux中，当一个进程退出（如调用exit等）后，并不是马上完全消失掉了，它还会留下一些踪迹，成为一个僵尸进程（Zombie）。作为一个僵尸进程来说，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。在僵尸进程记录了这个进程是怎么死亡的（是正常退出呢，还是出现了错误，还是被其它进程强迫退出的？），以及它占用的总系统CPU时间和总用户CPU时间分别是多少？还有发生页错误的数目和收到信号的数目等。</p>

<p>而wait和waitpid这两个系统调用就是用来收集这些信息，并使得这个僵尸进程永远消失的。</p>

<p>这两个系统调用的原型是这样子的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="cp">#include &lt;sys/wait.h&gt;  </span>
</span><span class='line'>
</span><span class='line'>  <span class="n">pid_t</span> <span class="n">wait</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">pit_t</span> <span class="n">wait</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span><span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">,</span><span class="kt">int</span> <span class="n">options</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于wait来说，它是等待所有的子进程的退出， 而对比来看，waitpid增加了两个参数<code>pid</code>和<code>option</code>。</p>

<p>对于pid来说，有四种情况：</p>

<table>
<thead>
<tr>
<th align="left">pid         </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">pid == -1   </td>
<td align="left"> 等待任一个子进程（与wait等效）；</td>
</tr>
<tr>
<td align="left">pid > 0     </td>
<td align="left"> 则等待其进程ID与pid相等的子进程。</td>
</tr>
<tr>
<td align="left">pid == 0    </td>
<td align="left"> 等待其组ID等于调用进程组ID的任一个子进程。</td>
</tr>
<tr>
<td align="left">pid &lt; -1    </td>
<td align="left"> 等待其组ID等于pid绝对值的任一子进程。</td>
</tr>
</tbody>
</table>


<p>另外，如果参数status的值不是NULL，wait就会把子进程退出时的状态取出并存入其中，这是一个整数值，指出了子进程是正常退出还是被非正常结束的，以及正常结束时的返回值，或被哪一个信号结束的等信息。有一套专门的宏（macro）来对其进行操作：</p>

<table>
<thead>
<tr>
<th align="left">macro               </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">WIFEXITED(status)   </td>
<td align="left"> 若子进程是正常退出的，则为真，此时可以调用WEXITSTATUS(status)获得退出值</td>
</tr>
<tr>
<td align="left">WEXITSTATUS(status) </td>
<td align="left"> 若子进程是被异常终止的，则为真，此时可以调用WTERMSIG(status)获得使其终止的信号编号</td>
</tr>
<tr>
<td align="left">WIFSTOPPED(status)  </td>
<td align="left"> 若子进程是暂停状态，则为真，此时可以调用WTERMSIG(status)获得使其暂停的信号编号</td>
</tr>
</tbody>
</table>


<p>到现在为止，还有一个参数叫option，它提供了一些额外的选项来控制waitpid，目前在Linux中只支持WNOHANG和WUNTRACED两个选项：</p>

<table>
<thead>
<tr>
<th align="left">Option      </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">WNOHANG     </td>
<td align="left"> waitpid在调用时发现没有已退出的子进程可收集，则返回0</td>
</tr>
<tr>
<td align="left">WUNTRACED   </td>
<td align="left"> 在所有符合条件的pid中，如果其中有已经stopped的进程，则立即返回（而对于traced的进程，即使没有该选项，如果其stopped了，也会立即返回）</td>
</tr>
</tbody>
</table>


<hr />

<h3>ptrace笔记</h3>

<p>ptrace可以做很多事，比如可以在用户层拦截和修改系统调用，在每次系统调用的时候改变子进程中的寄存器和内核映像，实现断点调试和系统调用的跟踪等等，具体的可以看玩转ptrace<a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_i/">1</a>和<a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_ii/">2</a>。这里对ptrace进行一个总结：</p>

<p>ptrace这个系统调用的作用是允许一个进程（the tracing process）来跟踪和控制另外一个进程（the traced process）。它的原型是这样的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;sys/ptrace.h&gt;</span>
</span><span class='line'><span class="kt">long</span> <span class="n">ptrace</span><span class="p">(</span><span class="k">enum</span> <span class="n">__ptrace_request</span> <span class="n">request</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个参数<code>request</code>决定了ptrace的行为与其它参数的使用方法，它可以有好多值，以下列出了几种比较常见的取值：</p>

<table>
<thead>
<tr>
<th align="left">request             </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">PTRACE_TRACEME      </td>
<td align="left"> 由子进程调用，让父进程跟踪自己（pid, addr, and data are ignored）</td>
</tr>
<tr>
<td align="left">PTRACE_PEEKTEXT     </td>
<td align="left"> 读取内存地址addr的值（data is ignored）</td>
</tr>
<tr>
<td align="left">PTRACE_PEEKDATA     </td>
<td align="left"> 同PTRACE_PEEKTEXT    </td>
</tr>
<tr>
<td align="left">PTRACE_PEEKUSER     </td>
<td align="left"> 读取tracee&#8217;s USER area的addr位移的数据（data is ignored）</td>
</tr>
<tr>
<td align="left">PTRACE_POKETEXT     </td>
<td align="left"> 将data中的值写入addr内存地址中</td>
</tr>
<tr>
<td align="left">PTRACE_POKEDATA     </td>
<td align="left"> 同PTRACE_POKETEXT</td>
</tr>
<tr>
<td align="left">PTRACE_POKEUSER     </td>
<td align="left"> 将data中的值写入tracee&#8217;s USER area的addr位移地址中</td>
</tr>
<tr>
<td align="left">PTRACE_GETREGS      </td>
<td align="left"> 将general-purpose寄存器写入data（addr is ignored）</td>
</tr>
<tr>
<td align="left">PTRACE_GETFPREGS    </td>
<td align="left"> 将 floating-point寄存器写入data（addr is ignored）</td>
</tr>
<tr>
<td align="left">PTRACE_SETREGS      </td>
<td align="left"> 修改tracee的general-purpose寄存器（addr is ignored)</td>
</tr>
<tr>
<td align="left">PTRACE_SETFPREGS    </td>
<td align="left"> 修改tracee的floating-point寄存器（addr is ignored)</td>
</tr>
<tr>
<td align="left">PTRACE_CONT         </td>
<td align="left"> 重启之前暂停的进程，如果data不为零，则代表发给进程的信号值（addr is ignored）</td>
</tr>
<tr>
<td align="left">PTRACE_SYSCALL,     </td>
<td align="left"> 执行PTRACE_CONT，并且使进程进入syscall-enter-stop和syscall-exit-stop模式</td>
</tr>
<tr>
<td align="left">PTRACE_SINGLESTEP   </td>
<td align="left"> 执行PTRACE_CONT，并且进行单点跟踪</td>
</tr>
<tr>
<td align="left">PTRACE_ATTACH       </td>
<td align="left"> 发送一个SIGSTOP信号到pid进程，并开始进行跟踪（addr and data are ignored）</td>
</tr>
<tr>
<td align="left">PTRACE_DETACH       </td>
<td align="left"> 先detach，然后执行PTRACE_CONT。</td>
</tr>
</tbody>
</table>


<p>除此之外，还有很多可用的取值，在linux的<a href="http://linux.die.net/man/2/ptrace">manpage</a>里面有很详细的描述。</p>

<p>需要注意的是，这里所说的attach和之后的一系列操作都是针对<strong>thread</strong>而言的，对于多线程来说，每一个thread都可以单独地被attach到一个跟踪者（tracer）。</p>

<p>在<a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_i/">玩转ptrace1</a>中举了一个很有趣的例子，可以通过这个例子来理解这些request都是怎么用的。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;sys/ptrace.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;sys/types.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;sys/wait.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;unistd.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;linux/user.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;sys/syscall.h&gt;</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">long_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">reverse</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>   <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">temp</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>        <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">temp</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>        <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'>        <span class="n">str</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">getdata</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">child</span><span class="p">,</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
</span><span class='line'>             <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>   <span class="kt">char</span> <span class="o">*</span><span class="n">laddr</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>    <span class="k">union</span> <span class="n">u</span> <span class="p">{</span>
</span><span class='line'>            <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'>            <span class="kt">char</span> <span class="n">chars</span><span class="p">[</span><span class="n">long_size</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span><span class="n">data</span><span class="p">;</span>
</span><span class='line'>    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">j</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">long_size</span><span class="p">;</span>
</span><span class='line'>    <span class="n">laddr</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">data</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span>
</span><span class='line'>                          <span class="n">child</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span>
</span><span class='line'>                          <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>        <span class="n">memcpy</span><span class="p">(</span><span class="n">laddr</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">chars</span><span class="p">,</span> <span class="n">long_size</span><span class="p">);</span>
</span><span class='line'>        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
</span><span class='line'>        <span class="n">laddr</span> <span class="o">+=</span> <span class="n">long_size</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">j</span> <span class="o">=</span> <span class="n">len</span> <span class="o">%</span> <span class="n">long_size</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">data</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span>
</span><span class='line'>                          <span class="n">child</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span>
</span><span class='line'>                          <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>        <span class="n">memcpy</span><span class="p">(</span><span class="n">laddr</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">chars</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">str</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">putdata</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">child</span><span class="p">,</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
</span><span class='line'>             <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>   <span class="kt">char</span> <span class="o">*</span><span class="n">laddr</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>    <span class="k">union</span> <span class="n">u</span> <span class="p">{</span>
</span><span class='line'>            <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'>            <span class="kt">char</span> <span class="n">chars</span><span class="p">[</span><span class="n">long_size</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span><span class="n">data</span><span class="p">;</span>
</span><span class='line'>    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">j</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">long_size</span><span class="p">;</span>
</span><span class='line'>    <span class="n">laddr</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">chars</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span> <span class="n">long_size</span><span class="p">);</span>
</span><span class='line'>        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKEDATA</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span>
</span><span class='line'>               <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
</span><span class='line'>        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
</span><span class='line'>        <span class="n">laddr</span> <span class="o">+=</span> <span class="n">long_size</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">j</span> <span class="o">=</span> <span class="n">len</span> <span class="o">%</span> <span class="n">long_size</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">chars</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
</span><span class='line'>        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKEDATA</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span>
</span><span class='line'>               <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="n">pid_t</span> <span class="n">child</span><span class="p">;</span>
</span><span class='line'>   <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
</span><span class='line'>   <span class="k">if</span><span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_TRACEME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>      <span class="n">execl</span><span class="p">(</span><span class="s">&quot;/bin/ls&quot;</span><span class="p">,</span> <span class="s">&quot;ls&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="kt">long</span> <span class="n">orig_eax</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">long</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="o">*</span><span class="n">laddr</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">toggle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>      <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>         <span class="n">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
</span><span class='line'>         <span class="k">if</span><span class="p">(</span><span class="n">WIFEXITED</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
</span><span class='line'>             <span class="k">break</span><span class="p">;</span>
</span><span class='line'>         <span class="n">orig_eax</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKUSER</span><span class="p">,</span>
</span><span class='line'>                           <span class="n">child</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">ORIG_EAX</span><span class="p">,</span>
</span><span class='line'>                           <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>         <span class="k">if</span><span class="p">(</span><span class="n">orig_eax</span> <span class="o">==</span> <span class="n">SYS_write</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">toggle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>               <span class="n">toggle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>               <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKUSER</span><span class="p">,</span>
</span><span class='line'>                                  <span class="n">child</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">EBX</span><span class="p">,</span>
</span><span class='line'>                                  <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>               <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKUSER</span><span class="p">,</span>
</span><span class='line'>                                  <span class="n">child</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">ECX</span><span class="p">,</span>
</span><span class='line'>                                  <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>               <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKUSER</span><span class="p">,</span>
</span><span class='line'>                                  <span class="n">child</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">EDX</span><span class="p">,</span>
</span><span class='line'>                                  <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>               <span class="n">str</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">((</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>                                 <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
</span><span class='line'>               <span class="n">getdata</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">str</span><span class="p">,</span>
</span><span class='line'>                       <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span><span class='line'>               <span class="n">reverse</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</span><span class='line'>               <span class="n">putdata</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">str</span><span class="p">,</span>
</span><span class='line'>                       <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>               <span class="n">toggle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>         <span class="p">}</span>
</span><span class='line'>      <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SYSCALL</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>首先子进程调用</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_TRACEME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>来让父进程跟踪自己，当然，这个也可以通过在父进程中调用</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_ATTACH</span><span class="p">,</span> <span class="n">traced_process_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>来实现，之后子进程运行了<code>bin/ls</code>。当子进程发生系统调用的时候会将控制权转交入父进程，父进程通过</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">orig_eax</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKUSER</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">ORIG_EAX</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>来获得eax寄存器的值（从而判断调用的是哪个系统调用），之后继续通过<code>PTRACE_PEEKUSER</code>这个request来获得SYS_write系统调用的其它参数(ebx, ecx, edx)，当然，这个步骤还可以用</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;linux/user.h&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">user_regs_struct</span> <span class="n">regs</span><span class="p">;</span>
</span><span class='line'><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>来替代，从而得到所有的寄存器的值regs。</p>

<p>之后，父进程在getdata函数中通过</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">data</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>将文件名从ecx中获得，并在putdata函数中通过</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKEDATA</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>将反转后的字符串写入寄存器ecx中，从而是的打出来的文件名是反转了的。</p>

<p>最后，通过调用</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SYSCALL</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>将控制权返还给子进程，同时让其进入syscall-enter-stop和syscall-exit-stop模式，即在进入和退出system call的时候都会stop，并将控制权交给父进程。</p>

<p>这里有一个问题，就是当子进程调用PTRACE_TRACEME或者父进程调用PTRACE_ATTACH之后，在什么情况下会将子进程stop（从而将控制权交给父进程）呢？</p>

<p>要回答这个问题，首先要知道当我们使用ptrace的时候，内核中发生了什么？这里有一段简要的说明：当一个进程调用了 ptrace(PTRACE_TRACEME, …)之后，内核为该进程设置了一个标记，注明该进程将被跟踪。内核中的相关原代码（位于<code>arch/i386/kernel/ptrace.c</code>）如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="n">PTRACE_TRACEME</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/* are we already being traced? */</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">&amp;</span> <span class="n">PT_PTRACED</span><span class="p">)</span>
</span><span class='line'>        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span><span class='line'>    <span class="cm">/* set the ptrace bit in the process flags. */</span>
</span><span class='line'>    <span class="n">current</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">|=</span> <span class="n">PT_PTRACED</span><span class="p">;</span>
</span><span class='line'>    <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>一次系统调用完成之后，内核察看那个标记，然后执行trace系统调用（如果这个进程正处于被跟踪状态的话）。其汇编的细节可以在 <code>arch/i386/kernel/entry.S</code>中找到。</p>

<p>现在让我们来看看这个sys_trace()函数（位于<code>arch/i386/kernel/ptrace.c</code>）。它停止子进程，然后发送一个信号给父进程，告诉它子进程已经停滞，这个信号会激活正处于等待状态的父进程，让父进程进行相关处理。父进程在完成相关操作以后就调用ptrace(PTRACE_CONT, …)或者 ptrace(PTRACE_SYSCALL, …)，这将唤醒子进程，内核此时所作的是调用一个叫<code>wake_up_process()</code>的进程调度函数。其他的一些系统架构可能会通过发送SIGCHLD给子进程来达到这个目的。</p>

<hr />

<p>由此可以看出，通过ptrace和wait(waitpid)等系统调用，可以使得父进程在系统调用的级别做子进程的跟踪和检查，由此来做很多的事情，但是有一个问题是，由于ptrace并不能指定哪些系统调用被跟踪，因此所有系统调用都会被stop并且转移控制权，由此会产生比较大的overhead。</p>

<p>总的来说，ptrace是一个非常强大的系统调用，这里只是介绍了其中几个比较常用的参数，更多的信息可以参照<a href="http://linux.die.net/man/2/ptrace">ptrace的manpage</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[系统调用学习笔记 - Linux系统调用表（转）]]></title>
    <link href="http://ytliu.github.com/blog/2013/04/28/xi-tong-diao-yong-xue-xi-bi-ji-linuxxi-tong-diao-yong-biao-%28zhuan-%29/"/>
    <updated>2013-04-28T20:56:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/04/28/xi-tong-diao-yong-xue-xi-bi-ji-linuxxi-tong-diao-yong-biao-(zhuan-)</id>
    <content type="html"><![CDATA[<p>最近发现自己对Linux里面很多的系统调用都不清楚具体是在怎么回事儿，想要好好学习一下。</p>

<p>在IBM的<a href="https://www.ibm.com/developerworks/cn/">developerWorks</a>中发现一份它们整理的<a href="http://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html">Linux系统调用列表</a>，从进程控制，文件系统控制等八个方面列举了大部分常见的Linux系统调用：</p>

<!-- more -->


<h2>进程控制</h2>

<table>
<thead>
<tr>
<th align="center">System Call             </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">fork                    </td>
<td align="left"> 创建一个新进程</td>
</tr>
<tr>
<td align="center">clone                   </td>
<td align="left"> 按指定条件创建子进程</td>
</tr>
<tr>
<td align="center">execve                  </td>
<td align="left"> 运行可执行文件</td>
</tr>
<tr>
<td align="center">exit                    </td>
<td align="left"> 中止进程</td>
</tr>
<tr>
<td align="center">_exit                   </td>
<td align="left"> 立即中止当前进程</td>
</tr>
<tr>
<td align="center">getdtablesize           </td>
<td align="left"> 进程所能打开的最大文件数</td>
</tr>
<tr>
<td align="center">getpgid                 </td>
<td align="left"> 获取指定进程组标识号</td>
</tr>
<tr>
<td align="center">setpgid                 </td>
<td align="left"> 设置指定进程组标志号</td>
</tr>
<tr>
<td align="center">getpgrp                 </td>
<td align="left"> 获取当前进程组标识号</td>
</tr>
<tr>
<td align="center">setpgrp                 </td>
<td align="left"> 设置当前进程组标志号</td>
</tr>
<tr>
<td align="center">getpid                  </td>
<td align="left"> 获取进程标识号</td>
</tr>
<tr>
<td align="center">getppid                 </td>
<td align="left"> 获取父进程标识号</td>
</tr>
<tr>
<td align="center">getpriority             </td>
<td align="left"> 获取调度优先级</td>
</tr>
<tr>
<td align="center">setpriority             </td>
<td align="left"> 设置调度优先级</td>
</tr>
<tr>
<td align="center">modify_ldt              </td>
<td align="left"> 读写进程的本地描述表</td>
</tr>
<tr>
<td align="center">nanosleep               </td>
<td align="left"> 使进程睡眠指定的时间</td>
</tr>
<tr>
<td align="center">nice                    </td>
<td align="left"> 改变分时进程的优先级</td>
</tr>
<tr>
<td align="center">pause                   </td>
<td align="left"> 挂起进程，等待信号</td>
</tr>
<tr>
<td align="center">personality             </td>
<td align="left"> 设置进程运行域</td>
</tr>
<tr>
<td align="center">prctl                   </td>
<td align="left"> 对进程进行特定操作</td>
</tr>
<tr>
<td align="center">ptrace                  </td>
<td align="left"> 进程跟踪</td>
</tr>
<tr>
<td align="center">sched_get_priority_max  </td>
<td align="left"> 取得静态优先级的上限</td>
</tr>
<tr>
<td align="center">sched_get_priority_min  </td>
<td align="left"> 取得静态优先级的下限</td>
</tr>
<tr>
<td align="center">sched_getparam          </td>
<td align="left"> 取得进程的调度参数</td>
</tr>
<tr>
<td align="center">sched_getscheduler      </td>
<td align="left"> 取得指定进程的调度策略</td>
</tr>
<tr>
<td align="center">sched_rr_get_interval   </td>
<td align="left"> 取得按RR算法调度的实时进程的时间片长度</td>
</tr>
<tr>
<td align="center">sched_setparam          </td>
<td align="left"> 设置进程的调度参数</td>
</tr>
<tr>
<td align="center">sched_setscheduler      </td>
<td align="left"> 设置指定进程的调度策略和参数</td>
</tr>
<tr>
<td align="center">sched_yield             </td>
<td align="left"> 进程主动让出处理器,并将自己等候调度队列队尾</td>
</tr>
<tr>
<td align="center">vfork                   </td>
<td align="left"> 创建一个子进程，以供执行新程序，常与execve等同时使用</td>
</tr>
<tr>
<td align="center">wait                    </td>
<td align="left"> 等待子进程终止</td>
</tr>
<tr>
<td align="center">wait3                   </td>
<td align="left"> 参见wait</td>
</tr>
<tr>
<td align="center">waitpid                 </td>
<td align="left"> 等待指定子进程终止</td>
</tr>
<tr>
<td align="center">wait4                   </td>
<td align="left"> 参见waitpid</td>
</tr>
<tr>
<td align="center">capget                  </td>
<td align="left"> 获取进程权限</td>
</tr>
<tr>
<td align="center">capset                  </td>
<td align="left"> 设置进程权限</td>
</tr>
<tr>
<td align="center">getsid                  </td>
<td align="left"> 获取会晤标识号</td>
</tr>
<tr>
<td align="center">setsid                  </td>
<td align="left"> 设置会晤标识号</td>
</tr>
</tbody>
</table>


<h2>文件系统控制</h2>

<h4>文件读写操作</h4>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">fcntl         </td>
<td align="left"> 文件控制</td>
</tr>
<tr>
<td align="center">open          </td>
<td align="left"> 打开文件</td>
</tr>
<tr>
<td align="center">creat         </td>
<td align="left"> 创建新文件</td>
</tr>
<tr>
<td align="center">close         </td>
<td align="left"> 关闭文件描述字</td>
</tr>
<tr>
<td align="center">read          </td>
<td align="left"> 读文件</td>
</tr>
<tr>
<td align="center">write         </td>
<td align="left"> 写文件</td>
</tr>
<tr>
<td align="center">readv         </td>
<td align="left"> 从文件读入数据到缓冲数组中</td>
</tr>
<tr>
<td align="center">writev        </td>
<td align="left"> 将缓冲数组里的数据写入文件</td>
</tr>
<tr>
<td align="center">pread         </td>
<td align="left"> 对文件随机读</td>
</tr>
<tr>
<td align="center">pwrite        </td>
<td align="left"> 对文件随机写</td>
</tr>
<tr>
<td align="center">lseek         </td>
<td align="left"> 移动文件指针</td>
</tr>
<tr>
<td align="center">_llseek       </td>
<td align="left"> 在64位地址空间里移动文件指针</td>
</tr>
<tr>
<td align="center">dup           </td>
<td align="left"> 复制已打开的文件描述字</td>
</tr>
<tr>
<td align="center">dup2          </td>
<td align="left"> 按指定条件复制文件描述字</td>
</tr>
<tr>
<td align="center">flock         </td>
<td align="left"> 文件加/解锁</td>
</tr>
<tr>
<td align="center">poll          </td>
<td align="left"> I/O多路转换</td>
</tr>
<tr>
<td align="center">truncate      </td>
<td align="left"> 截断文件</td>
</tr>
<tr>
<td align="center">ftruncate     </td>
<td align="left"> 参见truncate</td>
</tr>
<tr>
<td align="center">umask         </td>
<td align="left"> 设置文件权限掩码</td>
</tr>
<tr>
<td align="center">fsync         </td>
<td align="left"> 把文件在内存中的部分写回磁盘</td>
</tr>
</tbody>
</table>


<h4>文件系统操作</h4>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">access        </td>
<td align="left"> 确定文件的可存取性</td>
</tr>
<tr>
<td align="center">chdir         </td>
<td align="left"> 改变当前工作目录</td>
</tr>
<tr>
<td align="center">fchdir        </td>
<td align="left"> 参见chdir</td>
</tr>
<tr>
<td align="center">chmod         </td>
<td align="left"> 改变文件方式</td>
</tr>
<tr>
<td align="center">fchmod        </td>
<td align="left"> 参见chmod</td>
</tr>
<tr>
<td align="center">chown         </td>
<td align="left"> 改变文件的属主或用户组</td>
</tr>
<tr>
<td align="center">fchown        </td>
<td align="left"> 参见chown</td>
</tr>
<tr>
<td align="center">lchown        </td>
<td align="left"> 参见chown</td>
</tr>
<tr>
<td align="center">chroot        </td>
<td align="left"> 改变根目录</td>
</tr>
<tr>
<td align="center">stat          </td>
<td align="left"> 取文件状态信息</td>
</tr>
<tr>
<td align="center">lstat         </td>
<td align="left"> 参见stat</td>
</tr>
<tr>
<td align="center">fstat         </td>
<td align="left"> 参见stat</td>
</tr>
<tr>
<td align="center">statfs        </td>
<td align="left"> 取文件系统信息</td>
</tr>
<tr>
<td align="center">fstatfs       </td>
<td align="left"> 参见statfs</td>
</tr>
<tr>
<td align="center">readdir       </td>
<td align="left"> 读取目录项</td>
</tr>
<tr>
<td align="center">getdents      </td>
<td align="left"> 读取目录项</td>
</tr>
<tr>
<td align="center">mkdir         </td>
<td align="left"> 创建目录</td>
</tr>
<tr>
<td align="center">mknod         </td>
<td align="left"> 创建索引节点</td>
</tr>
<tr>
<td align="center">rmdir         </td>
<td align="left"> 删除目录</td>
</tr>
<tr>
<td align="center">rename        </td>
<td align="left"> 文件改名</td>
</tr>
<tr>
<td align="center">link          </td>
<td align="left"> 创建链接</td>
</tr>
<tr>
<td align="center">symlink       </td>
<td align="left"> 创建符号链接</td>
</tr>
<tr>
<td align="center">unlink        </td>
<td align="left"> 删除链接</td>
</tr>
<tr>
<td align="center">readlink      </td>
<td align="left"> 读符号链接的值</td>
</tr>
<tr>
<td align="center">mount         </td>
<td align="left"> 安装文件系统</td>
</tr>
<tr>
<td align="center">umount        </td>
<td align="left"> 卸下文件系统</td>
</tr>
<tr>
<td align="center">ustat         </td>
<td align="left"> 取文件系统信息</td>
</tr>
<tr>
<td align="center">utime         </td>
<td align="left"> 改变文件的访问修改时间</td>
</tr>
<tr>
<td align="center">utimes        </td>
<td align="left"> 参见utime</td>
</tr>
<tr>
<td align="center">quotactl      </td>
<td align="left"> 控制磁盘配额</td>
</tr>
</tbody>
</table>


<h2>系统控制</h2>

<table>
<thead>
<tr>
<th align="center">System Call         </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">ioctl               </td>
<td align="left"> I/O总控制函数</td>
</tr>
<tr>
<td align="center">_sysctl             </td>
<td align="left"> 读/写系统参数</td>
</tr>
<tr>
<td align="center">acct                </td>
<td align="left"> 启用或禁止进程记账</td>
</tr>
<tr>
<td align="center">getrlimit           </td>
<td align="left"> 获取系统资源上限</td>
</tr>
<tr>
<td align="center">setrlimit           </td>
<td align="left"> 设置系统资源上限</td>
</tr>
<tr>
<td align="center">getrusage           </td>
<td align="left"> 获取系统资源使用情况</td>
</tr>
<tr>
<td align="center">uselib              </td>
<td align="left"> 选择要使用的二进制函数库</td>
</tr>
<tr>
<td align="center">ioperm              </td>
<td align="left"> 设置端口I/O权限</td>
</tr>
<tr>
<td align="center">iopl                </td>
<td align="left"> 改变进程I/O权限级别</td>
</tr>
<tr>
<td align="center">outb                </td>
<td align="left"> 低级端口操作</td>
</tr>
<tr>
<td align="center">reboot              </td>
<td align="left"> 重新启动</td>
</tr>
<tr>
<td align="center">swapon              </td>
<td align="left"> 打开交换文件和设备</td>
</tr>
<tr>
<td align="center">swapoff             </td>
<td align="left"> 关闭交换文件和设备</td>
</tr>
<tr>
<td align="center">bdflush             </td>
<td align="left"> 控制bdflush守护进程</td>
</tr>
<tr>
<td align="center">sysfs               </td>
<td align="left"> 取核心支持的文件系统类型</td>
</tr>
<tr>
<td align="center">sysinfo             </td>
<td align="left"> 取得系统信息</td>
</tr>
<tr>
<td align="center">adjtimex            </td>
<td align="left"> 调整系统时钟</td>
</tr>
<tr>
<td align="center">alarm               </td>
<td align="left"> 设置进程的闹钟</td>
</tr>
<tr>
<td align="center">getitimer           </td>
<td align="left"> 获取计时器值</td>
</tr>
<tr>
<td align="center">setitimer           </td>
<td align="left"> 设置计时器值</td>
</tr>
<tr>
<td align="center">gettimeofday        </td>
<td align="left"> 取时间和时区</td>
</tr>
<tr>
<td align="center">settimeofday        </td>
<td align="left"> 设置时间和时区</td>
</tr>
<tr>
<td align="center">stime               </td>
<td align="left"> 设置系统日期和时间</td>
</tr>
<tr>
<td align="center">time                </td>
<td align="left"> 取得系统时间</td>
</tr>
<tr>
<td align="center">times               </td>
<td align="left"> 取进程运行时间</td>
</tr>
<tr>
<td align="center">uname               </td>
<td align="left"> 获取当前UNIX系统的名称、版本和主机等信息</td>
</tr>
<tr>
<td align="center">vhangup             </td>
<td align="left"> 挂起当前终端</td>
</tr>
<tr>
<td align="center">nfsservctl          </td>
<td align="left"> 对NFS守护进程进行控制</td>
</tr>
<tr>
<td align="center">vm86                </td>
<td align="left"> 进入模拟8086模式</td>
</tr>
<tr>
<td align="center">create_module       </td>
<td align="left"> 创建可装载的模块项</td>
</tr>
<tr>
<td align="center">delete_module       </td>
<td align="left"> 删除可装载的模块项</td>
</tr>
<tr>
<td align="center">init_module         </td>
<td align="left"> 初始化模块</td>
</tr>
<tr>
<td align="center">query_module        </td>
<td align="left"> 查询模块信息</td>
</tr>
<tr>
<td align="center">*get_kernel_syms    </td>
<td align="left"> 取得核心符号,已被query_module代替</td>
</tr>
</tbody>
</table>


<h2>内存管理</h2>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">brk           </td>
<td align="left"> 改变数据段空间的分配</td>
</tr>
<tr>
<td align="center">sbrk          </td>
<td align="left"> 参见brk</td>
</tr>
<tr>
<td align="center">mlock         </td>
<td align="left"> 内存页面加锁</td>
</tr>
<tr>
<td align="center">munlock       </td>
<td align="left"> 内存页面解锁</td>
</tr>
<tr>
<td align="center">mlockall      </td>
<td align="left"> 调用进程所有内存页面加锁</td>
</tr>
<tr>
<td align="center">munlockall    </td>
<td align="left"> 调用进程所有内存页面解锁</td>
</tr>
<tr>
<td align="center">mmap          </td>
<td align="left"> 映射虚拟内存页</td>
</tr>
<tr>
<td align="center">munmap        </td>
<td align="left"> 去除内存页映射</td>
</tr>
<tr>
<td align="center">mremap        </td>
<td align="left"> 重新映射虚拟内存地址</td>
</tr>
<tr>
<td align="center">msync         </td>
<td align="left"> 将映射内存中的数据写回磁盘</td>
</tr>
<tr>
<td align="center">mprotect      </td>
<td align="left"> 设置内存映像保护</td>
</tr>
<tr>
<td align="center">getpagesize   </td>
<td align="left"> 获取页面大小</td>
</tr>
<tr>
<td align="center">sync          </td>
<td align="left"> 将内存缓冲区数据写回硬盘</td>
</tr>
<tr>
<td align="center">cacheflush    </td>
<td align="left"> 将指定缓冲区中的内容写回磁盘</td>
</tr>
</tbody>
</table>


<h2>网络管理</h2>

<table>
<thead>
<tr>
<th align="center">System Call     </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">getdomainname   </td>
<td align="left"> 取域名</td>
</tr>
<tr>
<td align="center">setdomainname   </td>
<td align="left"> 设置域名</td>
</tr>
<tr>
<td align="center">gethostid       </td>
<td align="left"> 获取主机标识号</td>
</tr>
<tr>
<td align="center">sethostid       </td>
<td align="left"> 设置主机标识号</td>
</tr>
<tr>
<td align="center">gethostname     </td>
<td align="left"> 获取本主机名称</td>
</tr>
<tr>
<td align="center">sethostname     </td>
<td align="left"> 设置主机名称</td>
</tr>
</tbody>
</table>


<h2>Socket控制</h2>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">socketcall    </td>
<td align="left"> socket系统调用</td>
</tr>
<tr>
<td align="center">socket        </td>
<td align="left"> 建立socket</td>
</tr>
<tr>
<td align="center">bind          </td>
<td align="left"> 绑定socket到端口</td>
</tr>
<tr>
<td align="center">connect       </td>
<td align="left"> 连接远程主机</td>
</tr>
<tr>
<td align="center">accept        </td>
<td align="left"> 响应socket连接请求</td>
</tr>
<tr>
<td align="center">send          </td>
<td align="left"> 通过socket发送信息</td>
</tr>
<tr>
<td align="center">sendto        </td>
<td align="left"> 发送UDP信息</td>
</tr>
<tr>
<td align="center">sendmsg       </td>
<td align="left"> 参见send</td>
</tr>
<tr>
<td align="center">recv          </td>
<td align="left"> 通过socket接收信息</td>
</tr>
<tr>
<td align="center">recvfrom      </td>
<td align="left"> 接收UDP信息</td>
</tr>
<tr>
<td align="center">recvmsg       </td>
<td align="left"> 参见recv</td>
</tr>
<tr>
<td align="center">listen        </td>
<td align="left"> 监听socket端口</td>
</tr>
<tr>
<td align="center">select        </td>
<td align="left"> 对多路同步I/O进行轮询</td>
</tr>
<tr>
<td align="center">shutdown      </td>
<td align="left"> 关闭socket上的连接</td>
</tr>
<tr>
<td align="center">getsockname   </td>
<td align="left"> 取得本地socket名字</td>
</tr>
<tr>
<td align="center">getpeername   </td>
<td align="left"> 获取通信对方的socket名字</td>
</tr>
<tr>
<td align="center">getsockopt    </td>
<td align="left"> 取端口设置</td>
</tr>
<tr>
<td align="center">setsockopt    </td>
<td align="left"> 设置端口参数</td>
</tr>
<tr>
<td align="center">sendfile      </td>
<td align="left"> 在文件或端口间传输数据</td>
</tr>
<tr>
<td align="center">socketpair    </td>
<td align="left"> 创建一对已联接的无名socket</td>
</tr>
</tbody>
</table>


<h2>用户管理</h2>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">getuid        </td>
<td align="left"> 获取用户标识号</td>
</tr>
<tr>
<td align="center">setuid        </td>
<td align="left"> 设置用户标志号</td>
</tr>
<tr>
<td align="center">getgid        </td>
<td align="left"> 获取组标识号</td>
</tr>
<tr>
<td align="center">setgid        </td>
<td align="left"> 设置组标志号</td>
</tr>
<tr>
<td align="center">getegid       </td>
<td align="left"> 获取有效组标识号</td>
</tr>
<tr>
<td align="center">setegid       </td>
<td align="left"> 设置有效组标识号</td>
</tr>
<tr>
<td align="center">geteuid       </td>
<td align="left"> 获取有效用户标识号</td>
</tr>
<tr>
<td align="center">seteuid       </td>
<td align="left"> 设置有效用户标识号</td>
</tr>
<tr>
<td align="center">setregid      </td>
<td align="left"> 分别设置真实和有效的的组标识号</td>
</tr>
<tr>
<td align="center">setreuid      </td>
<td align="left"> 分别设置真实和有效的用户标识号</td>
</tr>
<tr>
<td align="center">getresgid     </td>
<td align="left"> 分别获取真实的,有效的和保存过的组标识号</td>
</tr>
<tr>
<td align="center">setresgid     </td>
<td align="left"> 分别设置真实的,有效的和保存过的组标识号</td>
</tr>
<tr>
<td align="center">getresuid     </td>
<td align="left"> 分别获取真实的,有效的和保存过的用户标识号</td>
</tr>
<tr>
<td align="center">setresuid     </td>
<td align="left"> 分别设置真实的,有效的和保存过的用户标识号</td>
</tr>
<tr>
<td align="center">setfsgid      </td>
<td align="left"> 设置文件系统检查时使用的组标识号</td>
</tr>
<tr>
<td align="center">setfsuid      </td>
<td align="left"> 设置文件系统检查时使用的用户标识号</td>
</tr>
<tr>
<td align="center">getgroups     </td>
<td align="left"> 获取后补组标志清单</td>
</tr>
<tr>
<td align="center">setgroups     </td>
<td align="left"> 设置后补组标志清单</td>
</tr>
</tbody>
</table>


<h2>进程间通信</h2>

<h4>信号</h4>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">sigaction     </td>
<td align="left"> 设置对指定信号的处理方法</td>
</tr>
<tr>
<td align="center">sigprocmask   </td>
<td align="left"> 根据参数对信号集中的信号执行阻塞/解除阻塞等操作</td>
</tr>
<tr>
<td align="center">sigpending    </td>
<td align="left"> 为指定的被阻塞信号设置队列</td>
</tr>
<tr>
<td align="center">sigsuspend    </td>
<td align="left"> 挂起进程等待特定信号</td>
</tr>
<tr>
<td align="center">signal        </td>
<td align="left"> 参见signal</td>
</tr>
<tr>
<td align="center">kill          </td>
<td align="left"> 向进程或进程组发信号</td>
</tr>
<tr>
<td align="center">*sigblock     </td>
<td align="left"> 向被阻塞信号掩码中添加信号,已被sigprocmask代替</td>
</tr>
<tr>
<td align="center">*siggetmask   </td>
<td align="left"> 取得现有阻塞信号掩码,已被sigprocmask代替</td>
</tr>
<tr>
<td align="center">*sigsetmask   </td>
<td align="left"> 用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替</td>
</tr>
<tr>
<td align="center">*sigmask      </td>
<td align="left"> 将给定的信号转化为掩码,已被sigprocmask代替</td>
</tr>
<tr>
<td align="center">*sigpause     </td>
<td align="left"> 作用同sigsuspend,已被sigsuspend代替</td>
</tr>
<tr>
<td align="center">sigvec        </td>
<td align="left"> 为兼容BSD而设的信号处理函数,作用类似sigaction</td>
</tr>
<tr>
<td align="center">ssetmask      </td>
<td align="left"> ANSI C的信号处理函数,作用类似sigaction</td>
</tr>
</tbody>
</table>


<h4>消息</h4>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">msgctl        </td>
<td align="left"> 消息控制操作</td>
</tr>
<tr>
<td align="center">msgget        </td>
<td align="left"> 获取消息队列</td>
</tr>
<tr>
<td align="center">msgsnd        </td>
<td align="left"> 发消息</td>
</tr>
<tr>
<td align="center">msgrcv        </td>
<td align="left"> 取消息</td>
</tr>
</tbody>
</table>


<h4>管道</h4>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">pipe          </td>
<td align="left"> 创建管道</td>
</tr>
</tbody>
</table>


<h4>信号量</h4>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">semctl        </td>
<td align="left"> 信号量控制</td>
</tr>
<tr>
<td align="center">semget        </td>
<td align="left"> 获取一组信号量</td>
</tr>
<tr>
<td align="center">semop         </td>
<td align="left"> 信号量操作</td>
</tr>
</tbody>
</table>


<h4>共享内存</h4>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">shmctl        </td>
<td align="left"> 控制共享内存</td>
</tr>
<tr>
<td align="center">shmget        </td>
<td align="left"> 获取共享内存</td>
</tr>
<tr>
<td align="center">shmat         </td>
<td align="left"> 连接共享内存</td>
</tr>
<tr>
<td align="center">shmdt         </td>
<td align="left"> 拆卸共享内存</td>
</tr>
</tbody>
</table>


<p>后面会慢慢对其中的某些进行详细的学习。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[同步原语学习笔记 - Lock，RCU和Transaction Memory]]></title>
    <link href="http://ytliu.github.com/blog/2013/04/14/tong-bu-yuan-yu-xue-xi-bi-ji-lock%2Crcuhe-transaction/"/>
    <updated>2013-04-14T14:24:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/04/14/tong-bu-yuan-yu-xue-xi-bi-ji-lock,rcuhe-transaction</id>
    <content type="html"><![CDATA[<p>这周最大的收获就是周四那天，感觉被洗脑了一样，上午P哥给我们讲他的<a href="http://ipads.se.sjtu.edu.cn/lib/exe/fetch.php?media=publications:reemu-ppopp13.pdf">ReEmu</a>，里面讲的最多的就是在它的replay系统中如何记录shared memory access order。还有一个就是Naruil下午讲的“The myth of lock &amp; scalability“，讲了lock，RCU，Transaction memory的一些基本原理和它们的发展过程，以及其中的一些scalability的问题。</p>

<p>关于ReEmu，主要是说需要记录哪些non-determinism：里面主要讲了interrupt，DMA handling，在不同cores发生page fault时的走页表顺序问题，对于一些non-deterministic的指令，比如in/out的处理，以及在共享内存访问中不同核的访问顺序。其中最重要的就是memory access order，即如何记录read-after-write, write-after-write和write-after-read的方法。这篇paper最大的贡献在于它利用了CREW（Concurrent Read，Exclusive Write）和seqlock的特性，利用version极大地减小了原子操作的数量，减小了log的大小，提高了efficiency和scalability。具体如何做的还是直接看paper吧，这里就不详述了。</p>

<p>这次主要想记的是Naruil关于一些同步原语的讲解。之前一直对Read-Write Lock, RCU，Transaction Memory等都只是一知半解，这几周由于海波和大爷的课，以及组会对这些都提到了好多，因此希望能把它们记下来做个笔记，省的自己又很快就忘记了。</p>

<!-- more -->


<p>slides在<a href="http://ipads.se.sjtu.edu.cn/courses/ads/slides/lec7-lock.pdf">这里</a>。</p>

<p>刚开始有个印象很深的提法，他说在计算机中不同核（或者在分布式系统中不同机器）之间的交流一般只有两种方式：<strong>message passing</strong>和<strong>shared memory</strong>，而对于第二种shared memory的方式，其本质上也是一种message passing（比如在多核之间的SM其实就是inter-processor间cache的message passing）。</p>

<p>还有一个印象很深的知识点就是对于我们平常提到的原子指令（比如test_and_set），只要是对于一个共享变量的原子指令，都会涉及到cache invalidation，即要把其它核的cache line都invalidate，这就是造成在多核环境下scalability上不去的原因，因为过多的原子指令将会造成in-flight的message太多（这个也是那篇<a href="http://pdos.csail.mit.edu/papers/linux:lock.pdf">Non-scalable locks are dangerous</a>强调的问题）。因此在同步原语中要想获得高的scalability，就必须减少对共享变量的原子操作（其实在ReEmu中它的目的也正是如此）。</p>

<h3>Read-Write Lock</h3>

<p>读写锁，顾名思义，就是将读锁和写锁分开来处理，对于读锁，它可以允许多个读者同时对一个共享变量进行读取，但是需要维护一个全局counter来记录读者的数量。当某个核产生一个写的请求，那么就不能再允许有新的读者进入critical section（CS），而写者也需要所有读者结束（即counter降为0）后才可以进入写的CS。在这里，一般的实现方式是这样的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">Read</span> <span class="n">object</span> <span class="n">begin</span>
</span><span class='line'>  <span class="n">P</span><span class="p">(</span><span class="n">object</span><span class="p">.</span><span class="n">lock</span><span class="p">)</span>
</span><span class='line'>  <span class="n">AtomicAdd</span><span class="p">(</span><span class="n">object</span><span class="p">.</span><span class="n">activeReader</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>  <span class="n">V</span><span class="p">(</span><span class="n">object</span><span class="p">.</span><span class="n">lock</span><span class="p">)</span>
</span><span class='line'>  <span class="n">Do</span> <span class="n">Actual</span> <span class="n">Read</span>
</span><span class='line'>  <span class="n">AtomicAdd</span><span class="p">(</span><span class="n">object</span><span class="p">.</span><span class="n">activeReaders</span><span class="p">,</span> <span class="err">−</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="n">end</span>
</span><span class='line'><span class="n">Write</span> <span class="n">object</span> <span class="n">begin</span>
</span><span class='line'>  <span class="n">P</span><span class="p">(</span><span class="n">object</span><span class="p">.</span><span class="n">lock</span><span class="p">)</span>
</span><span class='line'>  <span class="k">while</span> <span class="n">object</span><span class="p">.</span><span class="n">activeReaders</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">do</span> <span class="n">delay</span>
</span><span class='line'>  <span class="n">Do</span> <span class="n">Actual</span> <span class="n">Write</span>
</span><span class='line'>  <span class="n">V</span><span class="p">(</span><span class="n">object</span><span class="p">.</span><span class="n">lock</span><span class="p">)</span>
</span><span class='line'><span class="n">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里值得注意的是，虽然它减小了读者和读者之间信号量（P/V）的竞争，但是读者在读之前需要对共享变量activeReader进行原子加，安装前面所说的，这就会造成cache line invalidate message数量的增加，不具有很好的可扩展性。</p>

<p>为了减小等待message的时间，有一种解决方法叫GOLL:</p>

<p><img src="http://ytliu.info/images/2013-04-14-01.png" title="GOLL" alt="GOLL" /></p>

<p>即构造一棵二叉树，两个reader共享一个activeReader，而对于writer来说，只要其子节点存在activeReader，则它就为1。</p>

<p>另外一种方法叫BR lock：</p>

<p><img src="http://ytliu.info/images/2013-04-14-02.png" title="big reader lock" alt="BRLock" /></p>

<p>和GOLL相比，它为每一个reader都维护一个变量，这样在reader之间都完全不会存在message，但是对于writer来说，它的overhead则增大了很多，在writer进入CS之前，需要所有的reader都发message给它。</p>

<p>另外，如果我们为了增加公平性，采用一个ticket lock的形式，那么同样的，如果这个ticket是全局共享的，那么也会有同样的问题，于是就提出了一种叫做MCS lock的机制。</p>

<h3>MCS Lock</h3>

<p>MCS是由两个人(Mellor-Crummey and Scott)发明的算法，相比于需要维护一个全局变量的ticket based lock，在MCS lock中，每个进程只需要各自维护一个local variable，这个局部变量可以是一个用于spin的flag，用于标识自己是否拿到锁了。另外，存在一个全局的队列，拿锁的过程相当于向队列中插入一个结构体qnode，这个结构体包含了某个进程的flag——locked，和这个qnode指向的下一个qnode的地址：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">procedure</span> <span class="n">acquire_lock</span><span class="p">(</span> <span class="n">L</span><span class="o">:</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="n">I</span><span class="o">:</span> <span class="o">*</span><span class="n">qnode</span> <span class="p">)</span>
</span><span class='line'>  <span class="n">var</span> <span class="n">pred</span><span class="o">:</span> <span class="o">*</span><span class="n">qnode</span>
</span><span class='line'>  <span class="n">I</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">:=</span> <span class="n">nil</span> <span class="c1">// Initially, no successor</span>
</span><span class='line'>  <span class="n">pred</span> <span class="o">:=</span> <span class="n">swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span> <span class="c1">// Queue for lock</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">pred</span> <span class="mi">6</span><span class="o">=</span> <span class="n">nil</span> <span class="c1">// Lock was not free</span>
</span><span class='line'>      <span class="n">i</span><span class="o">-&gt;</span><span class="n">locked</span> <span class="o">:=</span> <span class="nb">true</span> <span class="c1">// Prepare to spin</span>
</span><span class='line'>      <span class="n">pred</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">:=</span> <span class="n">I</span> <span class="c1">// Link behind predecessor</span>
</span><span class='line'>      <span class="n">repeat</span> <span class="k">while</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">locked</span> <span class="c1">// Busy wait for lock</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这里，有一个变量<code>L</code>，它也是一个qnode，表示全局队列中最后一个拿锁插入的qnode，通过<code>swap(L, I)</code>（将I的值赋给L，并返回L的值），得到前一个拿锁的qnode pred，将它的next指向自己，并spin在自己的这个locked局部变量中。</p>

<p>而释放锁的过程也就显而易见了：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">procedure</span> <span class="n">release_lock</span><span class="p">(</span> <span class="n">L</span><span class="o">:</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="n">I</span><span class="o">:</span> <span class="o">*</span><span class="n">qnode</span> <span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">nil</span> <span class="c1">// No known successor</span>
</span><span class='line'>      <span class="k">if</span> <span class="n">compare_and_swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">nil</span><span class="p">)</span>
</span><span class='line'>          <span class="k">return</span> <span class="c1">// No successor, lock free</span>
</span><span class='line'>      <span class="n">repeat</span> <span class="k">while</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">nil</span> <span class="c1">// Wait for successor</span>
</span><span class='line'>  <span class="n">I</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">locked</span> <span class="o">:=</span> <span class="nb">false</span> <span class="c1">// Pass lock</span>
</span></code></pre></td></tr></table></div></figure>


<p>先判断自己是不是最后一个拿锁的人，如果不是，则将下一个qnode的locked设成false，即将锁传递给下一个qnode。</p>

<p>由于MCS lock是spin在自己的局部变量上的，所以就没有前面说过的scalability的问题。不过MCS对于核数比较少的情况似乎性能不是很好（这个我也不是很理解）。</p>

<h3>RCU (Read-Copy-Updata)</h3>

<p>除了lock之后，还有一种同步原语叫RCU：</p>

<p><img src="http://ytliu.info/images/2013-04-14-03.png" title="RCU" alt="RCU" /></p>

<p>RCU最大的特点在于writer可以在reader进行读取操作的时候直接修改，不过需要注意的是，这里的修改是这样的：</p>

<ul>
<li>首先对Shared_data进行一次拷贝（到一个新的地址B）；</li>
<li>更新B指向的对象；</li>
<li>将Shared_data原来的地址赋给一个新的变量Old_data；</li>
<li>将Shared_data赋值为B。</li>
</ul>


<p>这样有一个问题就是，几个reader可能会在一段时间内读到的值是不一样的，有些读到的是old value，有些读到的是new value。但是可以保证的是，当执行完</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">Shared_data</span> <span class="o">=</span> <span class="n">B</span>
</span></code></pre></td></tr></table></div></figure>


<p>之后，所有的reader读到的值都是改过后的值！</p>

<p>另外这里还要考虑一个问题，那就是什么时候释放这个Old_data？</p>

<p>这里注意在Reader的代码中，<code>rcu_read_lock()</code>会关闭中断，禁止在一个核中其它进程的抢断，而<code>rcu_read_unlock()</code>则会打开中断，恢复抢断机制。于是writer就可以根据reader进程是否进行过context switch来判断说是否对Shared_data的读过程是否全部结束了：</p>

<p><img src="http://ytliu.info/images/2013-04-14-04.png" title="RCU Figure" alt="RCU figure 2" /></p>

<p>RCU还要考虑的一个问题是在reader中是否能允许sleep？因为如果一个reader在读的过程中如果碰到一段IO操作，那么它如果不sleep的话，则会很大地浪费CPU资源，而如果sleep的话，则会发生一次context switch，而此时，读的过程其实并没有结束，与RCU的语义就不符了。</p>

<p>对于这个问题，按照Naruil的说法，也产生了一系列研究，比如允许sleep的RCU等，这里就不展开了（其实是我也不懂啦）。</p>

<p>和之前提到的RW lock等相比，RCU没有scalability的问题，性能会好很多。所以当前RCU被运用到Linux的很多地方，这里有一个插曲是说当年发明RCU的是作者是IBM的一个员工，它就靠着RCU这么一个东西在IBM待了20多年，而RCU也被申请了专利，像FreeBSD这些系统是不被允许使用RCU的。</p>

<p>当然RCU还有很多问题，比如它有很多semantic的限制，对于那些不允许在一段时间内多个reader会读到不同值的情况就不能使用RCU。另外，RCU只能应用在一些比较简单的数据结构中，如果遇到比较复杂的数据结果就挂掉了，因为它需要程序员自己处理很多corner cases。</p>

<h3>Transaction Memory</h3>

<p>最后要讲的一个同步原语就是Transaction Memory（TM），这个最近几年很火的一个研究方向，特别是当Hardware TM（HTM）问世之后。</p>

<p>安装Naruil的说法，TM的原理大概是这样的：在一个Transaction中，可以访问不同的对象（这个粒度可以自己控制，可以是几个cache line，几个page&#8230;)，而当访问了某个对象之后，它对应的cache line上就会有一个flag标识，当一个进程进行commit，则会将自己对应的那些cache line上的flag清楚，而对于其它访问了这些cache line的transaction，则会abort，并invalidate 这些cache line。</p>

<p>TM的好处在于它可以非常细粒度地进行同步，并且避免了对lock这样一个额外的同步变量维护产生的cache message。</p>

<hr />

<p>同步原语真的是一个非常需要智商的领域，我最近对此感觉特别深刻。我想在这个领域里搞研究的应该都是一群智商超群的人吧:)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Netfilter学习笔记（三）]]></title>
    <link href="http://ytliu.github.com/blog/2013/04/09/netfilterxue-xi-bi-ji-%28san-%29/"/>
    <updated>2013-04-09T21:21:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/04/09/netfilterxue-xi-bi-ji-(san-)</id>
    <content type="html"><![CDATA[<p>这次的内容主要是关于在Android上如何使用iptables。</p>

<p>其实在android源码中已经有对iptables进行了支持，如何确定可以参看<a href="http://www.roman10.net/how-to-build-and-use-libnetfilter_queue-for-android/">这里</a>。</p>

<p>这里简单说下如何采用nfqueue对其进行控制：</p>

<p>首先说下一个很简单的场景：我们需要将从手机端发到192.168.1.2服务器的所有TCP包都拦截下来，将包的信息打印出来，并将其发送出去。</p>

<!-- more -->


<p>具体的步骤如下：</p>

<ul>
<li><p>首先将手机连到PC上，运行：</p>

<p>  $ adb shell
  $ su
  #</p></li>
</ul>


<p>进入root模式，这个时候可以配置iptables：</p>

<pre><code># iptables -A OUTPUT -t tcp -d 192.168.1.2 -j NFQUEUE
</code></pre>

<p>这样到192.168.1.2的所有TCP包都会进入NFQUEUE等着被处理。</p>

<ul>
<li><p>此时我们需要写程序来处理NFQUEUE里面的包，首先我们在PC上新建一个Android项目：</p>

<p>  $ android create project &#8211;target <target_ID> -name IptablesTest &#8211;path ./IptablesTest &#8211;activity IptablesTestActivity  &#8211;package com.iptables.test
  $ cd IptablesTest
  $ mkdir jni</p></li>
</ul>


<p>接下来，要下载两个包（<a href="http://www.netfilter.org/projects/libnfnetlink/downloads.html">libnfnetlink</a>和<a href="http://www.netfilter.org/projects/libnetfilter_queue/downloads.html">libnetfilter_queue</a>）到jni目录下。</p>

<p>然后在jni目录下创建一个文件叫做nfqnl_test.c：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;unistd.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;netinet/in.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;linux/types.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;linux/netfilter.h&gt;       </span><span class="cm">/* for NF_ACCEPT */</span><span class="cp"></span>
</span><span class='line'><span class="cp">#include &lt;errno.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;libnetfilter_queue/libnetfilter_queue.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* returns packet id */</span>
</span><span class='line'><span class="k">static</span> <span class="n">u_int32_t</span> <span class="nf">print_pkt</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nfq_data</span> <span class="o">*</span><span class="n">tb</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">nfqnl_msg_packet_hdr</span> <span class="o">*</span><span class="n">ph</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">nfqnl_msg_packet_hw</span> <span class="o">*</span><span class="n">hwph</span><span class="p">;</span>
</span><span class='line'>  <span class="n">u_int32_t</span> <span class="n">mark</span><span class="p">,</span><span class="n">ifi</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ph</span> <span class="o">=</span> <span class="n">nfq_get_msg_packet_hdr</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">ph</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">id</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">packet_id</span><span class="p">);</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hw_protocol=0x%04x hook=%u id=%u &quot;</span><span class="p">,</span>
</span><span class='line'>          <span class="n">ntohs</span><span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">hw_protocol</span><span class="p">),</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">hook</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">hwph</span> <span class="o">=</span> <span class="n">nfq_get_packet_hw</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">hwph</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">hlen</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">hwph</span><span class="o">-&gt;</span><span class="n">hw_addrlen</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hw_src_addr=&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hlen</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>          <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%02x:&quot;</span><span class="p">,</span> <span class="n">hwph</span><span class="o">-&gt;</span><span class="n">hw_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="n">hwph</span><span class="o">-&gt;</span><span class="n">hw_addr</span><span class="p">[</span><span class="n">hlen</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">mark</span> <span class="o">=</span> <span class="n">nfq_get_nfmark</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">mark</span><span class="p">)</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;mark=%u &quot;</span><span class="p">,</span> <span class="n">mark</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ifi</span> <span class="o">=</span> <span class="n">nfq_get_indev</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">ifi</span><span class="p">)</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;indev=%u &quot;</span><span class="p">,</span> <span class="n">ifi</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ifi</span> <span class="o">=</span> <span class="n">nfq_get_outdev</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">ifi</span><span class="p">)</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;outdev=%u &quot;</span><span class="p">,</span> <span class="n">ifi</span><span class="p">);</span>
</span><span class='line'>  <span class="n">ifi</span> <span class="o">=</span> <span class="n">nfq_get_physindev</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">ifi</span><span class="p">)</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;physindev=%u &quot;</span><span class="p">,</span> <span class="n">ifi</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ifi</span> <span class="o">=</span> <span class="n">nfq_get_physoutdev</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">ifi</span><span class="p">)</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;physoutdev=%u &quot;</span><span class="p">,</span> <span class="n">ifi</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ret</span> <span class="o">=</span> <span class="n">nfq_get_payload</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;payload_len=%d &quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">fputc</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="n">id</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>  
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="nf">cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfq_q_handle</span> <span class="o">*</span><span class="n">qh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfgenmsg</span> <span class="o">*</span><span class="n">nfmsg</span><span class="p">,</span>
</span><span class='line'>        <span class="k">struct</span> <span class="n">nfq_data</span> <span class="o">*</span><span class="n">nfa</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">u_int32_t</span> <span class="n">id</span> <span class="o">=</span> <span class="n">print_pkt</span><span class="p">(</span><span class="n">nfa</span><span class="p">);</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;entering callback</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">nfq_set_verdict</span><span class="p">(</span><span class="n">qh</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">NF_ACCEPT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">nfq_handle</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">nfq_q_handle</span> <span class="o">*</span><span class="n">qh</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">nfnl_handle</span> <span class="o">*</span><span class="n">nh</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4096</span><span class="p">]</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;opening library handle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">h</span> <span class="o">=</span> <span class="n">nfq_open</span><span class="p">();</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;error during nfq_open()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;unbinding existing nf_queue handler for AF_INET (if any)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">nfq_unbind_pf</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;error during nfq_unbind_pf()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;binding nfnetlink_queue as nf_queue handler for AF_INET</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">nfq_bind_pf</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;error during nfq_bind_pf()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;binding this socket to queue &#39;0&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">qh</span> <span class="o">=</span> <span class="n">nfq_create_queue</span><span class="p">(</span><span class="n">h</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qh</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;error during nfq_create_queue()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;setting copy_packet mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">nfq_set_mode</span><span class="p">(</span><span class="n">qh</span><span class="p">,</span> <span class="n">NFQNL_COPY_PACKET</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;can&#39;t set packet_copy mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">fd</span> <span class="o">=</span> <span class="n">nfq_fd</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">((</span><span class="n">rv</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">printf</span><span class="p">(</span><span class="s">&quot;pkt received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>          <span class="n">nfq_handle_packet</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">rv</span><span class="p">);</span>
</span><span class='line'>          <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">ENOBUFS</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">printf</span><span class="p">(</span><span class="s">&quot;losing packets!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>          <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="n">perror</span><span class="p">(</span><span class="s">&quot;recv failed&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="k">break</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;unbinding from queue 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">nfq_destroy_queue</span><span class="p">(</span><span class="n">qh</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;closing library handle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">nfq_close</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的原理很简单，就是通过：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">qh</span> <span class="o">=</span> <span class="n">nfq_create_queue</span><span class="p">(</span><span class="n">h</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>注册了一个callback函数cb，在</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">nfq_handle_packet</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">rv</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>的时候就会将收到的包传给该函数进行处理，当然了，还可以像<a href="http://ytliu.info/blog/2013/03/29/netfilterxue-xi-bi-ji-%28er-%29/">这里</a>一样通过<code>struct iphdr</code>和<code>struct tcphdr</code>结构体来获得payload里面的IP包头和TCP包的信息，对其进行处理。</p>

<ul>
<li>之后在jni目录下创建<code>Android.mk</code>文件：</li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#LOCAL_PATH is used to locate source files in the development tree.</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#the macro my-dir provided by the build system, indicates the path of the current directory</span>
</span><span class='line'>
</span><span class='line'><span class="nl">LOCAL_PATH:</span><span class="o">=</span><span class="err">$</span><span class="p">(</span><span class="n">call</span> <span class="n">my</span><span class="o">-</span><span class="n">dir</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">#####################################################################</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#            build libnflink                    #</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#####################################################################</span>
</span><span class='line'>
</span><span class='line'><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">CLEAR_VARS</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nl">LOCAL_MODULE:</span><span class="o">=</span><span class="n">nflink</span>
</span><span class='line'>
</span><span class='line'><span class="n">LOCAL_C_INCLUDES</span> <span class="o">:=</span> <span class="err">$</span><span class="p">(</span><span class="n">LOCAL_PATH</span><span class="p">)</span><span class="o">/</span><span class="n">libnfnetlink</span><span class="o">-</span><span class="mf">1.0.0</span><span class="o">/</span><span class="n">include</span>
</span><span class='line'>
</span><span class='line'><span class="nl">LOCAL_SRC_FILES:</span><span class="o">=</span>\
</span><span class='line'>
</span><span class='line'>    <span class="n">libnfnetlink</span><span class="o">-</span><span class="mf">1.0.0</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">iftable</span><span class="p">.</span><span class="n">c</span> \
</span><span class='line'>
</span><span class='line'>    <span class="n">libnfnetlink</span><span class="o">-</span><span class="mf">1.0.0</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">rtnl</span><span class="p">.</span><span class="n">c</span> \
</span><span class='line'>
</span><span class='line'>    <span class="n">libnfnetlink</span><span class="o">-</span><span class="mf">1.0.0</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">libnfnetlink</span><span class="p">.</span><span class="n">c</span>
</span><span class='line'>
</span><span class='line'><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">BUILD_STATIC_LIBRARY</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include $(BUILD_SHARED_LIBRARY)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">#####################################################################</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#            build libnetfilter_queue            #</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#####################################################################</span>
</span><span class='line'>
</span><span class='line'><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">CLEAR_VARS</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">LOCAL_C_INCLUDES</span> <span class="o">:=</span> <span class="err">$</span><span class="p">(</span><span class="n">LOCAL_PATH</span><span class="p">)</span><span class="o">/</span><span class="n">libnfnetlink</span><span class="o">-</span><span class="mf">1.0.0</span><span class="o">/</span><span class="n">include</span> \
</span><span class='line'>
</span><span class='line'>    <span class="err">$</span><span class="p">(</span><span class="n">LOCAL_PATH</span><span class="p">)</span><span class="o">/</span><span class="n">libnetfilter_queue</span><span class="o">-</span><span class="mf">1.0.0</span><span class="o">/</span><span class="n">include</span>
</span><span class='line'>
</span><span class='line'><span class="nl">LOCAL_MODULE:</span><span class="o">=</span><span class="n">netfilter_queue</span>
</span><span class='line'>
</span><span class='line'><span class="nl">LOCAL_SRC_FILES:</span><span class="o">=</span><span class="n">libnetfilter_queue</span><span class="o">-</span><span class="mf">1.0.0</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">libnetfilter_queue</span><span class="p">.</span><span class="n">c</span>
</span><span class='line'>
</span><span class='line'><span class="nl">LOCAL_STATIC_LIBRARIES:</span><span class="o">=</span><span class="n">libnflink</span>
</span><span class='line'>
</span><span class='line'><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">BUILD_STATIC_LIBRARY</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include $(BUILD_SHARED_LIBRARY)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">#####################################################################</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#            build our code                    #</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#####################################################################</span>
</span><span class='line'>
</span><span class='line'><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">CLEAR_VARS</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">LOCAL_C_INCLUDES</span> <span class="o">:=</span> <span class="err">$</span><span class="p">(</span><span class="n">LOCAL_PATH</span><span class="p">)</span><span class="o">/</span><span class="n">libnfnetlink</span><span class="o">-</span><span class="mf">1.0.0</span><span class="o">/</span><span class="n">include</span> \
</span><span class='line'>
</span><span class='line'>    <span class="err">$</span><span class="p">(</span><span class="n">LOCAL_PATH</span><span class="p">)</span><span class="o">/</span><span class="n">libnetfilter_queue</span><span class="o">-</span><span class="mf">1.0.0</span><span class="o">/</span><span class="n">include</span>
</span><span class='line'>
</span><span class='line'><span class="nl">LOCAL_MODULE:</span><span class="o">=</span><span class="n">nfqnltest</span>
</span><span class='line'>
</span><span class='line'><span class="nl">LOCAL_SRC_FILES:</span><span class="o">=</span><span class="n">nfqnl_test</span><span class="p">.</span><span class="n">c</span>
</span><span class='line'>
</span><span class='line'><span class="nl">LOCAL_STATIC_LIBRARIES:</span><span class="o">=</span><span class="n">libnetfilter_queue</span>
</span><span class='line'>
</span><span class='line'><span class="nl">LOCAL_LDLIBS:</span><span class="o">=-</span><span class="n">llog</span> <span class="o">-</span><span class="n">lm</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include $(BUILD_SHARED_LIBRARY)</span>
</span><span class='line'>
</span><span class='line'><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">BUILD_EXECUTABLE</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>之后，调用ndk-build来创建可执行文件nfqnltest，它位于libs目录下。</p></li>
<li><p>将nfqnltest传进Android中：</p>

<p>  $ adb shell
  $ su
  # mkdir /data/data/nfqnltest
  # chmod 777 /data/data/nfqnltest</p></li>
</ul>


<p>打开一个shell：</p>

<pre><code>$ adb push libs/nfqnltest /data/data/nfqnltest/”
</code></pre>

<p>转回刚刚那个shell</p>

<pre><code># cd /data/data/nfqnltest
# ./nfqnltest
</code></pre>

<p>这样整个过程就完成了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Netfilter学习笔记（二）]]></title>
    <link href="http://ytliu.github.com/blog/2013/03/29/netfilterxue-xi-bi-ji-%28er-%29/"/>
    <updated>2013-03-29T20:26:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/03/29/netfilterxue-xi-bi-ji-(er-)</id>
    <content type="html"><![CDATA[<p>之前讲了关于netfilter和iptables的一些简单的原理和用法，对于iptables来说，如果只能对封包进行DROP、ACCEPT操作，那么就显得太弱了，其实在我看来iptables里面filter表中最牛逼的就在于QUEUE（NFQUEUE）这个target了。</p>

<p>那么当iptables将封包插入QUEUE后，用户态又能用什么方法才能读到queue中的数据呢？</p>

<p>这里介绍两种方法，一种是C语言中使用的<code>libipq</code>，一种是python中使用的<code>nfqueue</code>。</p>

<!-- more -->


<h3>libipq</h3>

<p><code>libipq</code>是一个对开发者提供的用于读取iptables queue的C库，具体的用法可以参看<a href="http://linux.die.net/man/3/libipq">linux man page</a>和<a href="http://www.imchris.org/projects/libipq.html">这里</a>的用法，需要注意的是在我的机器中必须得再加三个头文件：</p>

<pre><code>#include &lt;netinet/in.h&gt;
#include &lt;linux/ip.h&gt;
#include &lt;linux/tcp.h&gt;
</code></pre>

<p>另外编译出来的文件必须得用<code>sudo</code>执行！！！</p>

<p>这里主要用了一个数据结构</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">ipq_handle</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">h</span> <span class="o">=</span> <span class="n">ipq_create_handle</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">PF_INET</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外需要设置一个模式，这里是<code>IPQ_COPY_PACKET</code>，即是将queue中的封包的payload和header一起拷贝到用户空间：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">status</span> <span class="o">=</span> <span class="n">ipq_set_mode</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">IPQ_COPY_PACKET</span><span class="p">,</span> <span class="n">BUFSIZE</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>之后通过：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">status</span> <span class="o">=</span> <span class="n">ipq_read</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUFSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>将queueu中的封包一个一个拷贝到用户空间，由用户进行操作，用户可以通过：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">ipq_message_type</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>得到包的类型，可能是<code>NLMSG_ERROR</code>，也有可能是<code>IPQM_PACKET</code>，如果是后者，即为一个正常的封包，可以通过类似于如下的代码对封包进行操作：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">case</span> <span class="n">IPQM_PACKET</span>: <span class="p">{</span>
</span><span class='line'>  <span class="n">ipq_packet_msg_t</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">ipq_get_packet</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="o">*</span><span class="p">)</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">tcp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">payload</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">tcp</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">);</span>         
</span><span class='line'>
</span><span class='line'>  <span class="n">status</span> <span class="o">=</span> <span class="n">ipq_set_verdict</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">packet_id</span><span class="p">,</span> <span class="n">NF_ACCEPT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">die</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
</span><span class='line'>      <span class="k">break</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上段代码的意思是先从<code>buf</code>中获得整个封包m，之后可以通过<code>struct iphdr</code>和<code>struct tcphdr</code>获得ip包头和tcp包头，最后有一个最关键的代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">status</span> <span class="o">=</span> <span class="n">ipq_set_verdict</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">packet_id</span><span class="p">,</span> <span class="n">NF_ACCEPT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的意思相当于原来在规则中target设为ACCEPT，当然也可以设置成<code>NF_DROP</code>等。</p>

<p>在这里我有一个疑问，就是这里除了获得<code>struct tcphdr</code>之外，我没有找到和TCP的payload相关的结构，不知道该如何获得。</p>

<hr />

<h3>nfqueue</h3>

<p>和C的libipq比起来，支持python的nfqueue会显得强大很多，特别是和<a href="http://www.secdev.org/projects/scapy/">scapy</a>结合起来用的时候。</p>

<p>首先需要说明的是在iptables中的target除了之前提到的五项（ACCEPT，DROP，RETURN，QUEUE，other_chain）之外，还有一个叫<code>NFQUEUE</code>，它是QUEUE的扩展。相比于QUEUE，它可以由用户指定不同的queue number。</p>

<p>在使用nfqueue之前，需要安装如下的包：</p>

<pre><code>$ sudo aptitude install libnetfilter-queue-dev
$ sudo aptitude install nfqueue-bindings-python
$ sudo aptitude install python-scapy
</code></pre>

<p>之后就可以采用python对NFQUEUE进行操作了。</p>

<p>假设我们将封包从主机A（<code>192.168.1.1</code>）传输到主机B（<code>192.168.1.2</code>）时，需要对封包进行分析，如果是TCP协议的包，并且其flags为 ACK|PSH 的话，则将其payload进行修改（比如替换成“hack”）：</p>

<p>首先，需要先在主机A中对iptables进行操作：</p>

<pre><code>$ sudo iptables -A OUTPUT -d 192.168.1.2 -p tcp -j NFQUEUE
</code></pre>

<p>然后利用下面的代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">os</span><span class="o">,</span><span class="nn">sys</span><span class="o">,</span><span class="nn">nfqueue</span><span class="o">,</span><span class="nn">socket</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">scapy.all</span> <span class="kn">import</span> <span class="o">*</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">ch_payload_and_send</span><span class="p">(</span><span class="n">pkt</span><span class="p">):</span>
</span><span class='line'>  <span class="n">pkt</span><span class="p">[</span><span class="n">TCP</span><span class="p">]</span><span class="o">.</span><span class="n">payload</span> <span class="o">==</span> <span class="s">&quot;hack&quot;</span>
</span><span class='line'>  <span class="n">send</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">payload</span><span class="p">):</span>
</span><span class='line'>  <span class="n">data</span> <span class="o">=</span> <span class="n">payload</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
</span><span class='line'>  <span class="n">pkt</span> <span class="o">=</span> <span class="n">IP</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c"># Check if TCP flags is ACK|PSH</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">pkt</span><span class="p">[</span><span class="n">TCP</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span> <span class="o">==</span> <span class="mi">24</span><span class="p">:</span>
</span><span class='line'>      <span class="c"># Dropping the packet</span>
</span><span class='line'>      <span class="n">payload</span><span class="o">.</span><span class="n">set_verdict</span><span class="p">(</span><span class="n">nfqueue</span><span class="o">.</span><span class="n">NF_DROP</span><span class="p">)</span>
</span><span class='line'>      <span class="n">ch_payload_and_send</span><span class="p">(</span><span class="n">pkt</span><span class="p">)</span>
</span><span class='line'>  <span class="k">else</span><span class="p">:</span>
</span><span class='line'>      <span class="c"># Accepting the packet</span>
</span><span class='line'>      <span class="n">payload</span><span class="o">.</span><span class="n">set_verdict</span><span class="p">(</span><span class="n">nfqueue</span><span class="o">.</span><span class="n">NF_ACCEPT</span><span class="p">)</span>
</span><span class='line'>  
</span><span class='line'><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span><span class='line'>  <span class="n">q</span> <span class="o">=</span> <span class="n">nfqueue</span><span class="o">.</span><span class="n">queue</span><span class="p">()</span>
</span><span class='line'>  <span class="n">q</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
</span><span class='line'>  <span class="n">q</span><span class="o">.</span><span class="n">unbind</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">)</span>
</span><span class='line'>  <span class="n">q</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">)</span>
</span><span class='line'>  <span class="n">q</span><span class="o">.</span><span class="n">set_callback</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>
</span><span class='line'>  <span class="n">q</span><span class="o">.</span><span class="n">create_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">try</span><span class="p">:</span>
</span><span class='line'>      <span class="n">q</span><span class="o">.</span><span class="n">try_run</span><span class="p">()</span>
</span><span class='line'>  <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
</span><span class='line'>      <span class="k">print</span> <span class="s">&quot;Exiting...&quot;</span>
</span><span class='line'>      <span class="n">q</span><span class="o">.</span><span class="n">unbind</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">)</span>
</span><span class='line'>      <span class="n">q</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span><span class='line'>      <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">main</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里用到了<code>scapy</code>这个非常牛逼的模块，它可以直接通过如<code>IP()</code>，<code>TCP()</code>等直接对包进行解释和操作，非常方便，具体的可以参看它的<a href="http://www.secdev.org/projects/scapy/doc/">文档</a>。这里只是说明下它的安装方式：</p>

<pre><code>$ wget scapy.net
$ mv index.html scapy-latest.zip
$ chmod +x scapy-latest.zip
$ mv scapy-latest.zip /usr/local/bin/scapy
</code></pre>

<p>然后就可以运行：</p>

<pre><code>$ sudo scapy
</code></pre>

<p>直接开启scapy的交互模式了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Netfilter学习笔记（一）]]></title>
    <link href="http://ytliu.github.com/blog/2013/03/29/netfilterxue-xi-bi-ji-%28yi-%29/"/>
    <updated>2013-03-29T18:39:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/03/29/netfilterxue-xi-bi-ji-(yi-)</id>
    <content type="html"><![CDATA[<p>这两天在学习<code>iptables</code>，感觉这个东西实在是太牛逼！想用两篇博文来介绍一番。</p>

<p>第一篇会介绍下netfilter和iptables的关系，以及iptables的原理；第二篇希望通过<code>libipq</code>和<code>nfqueue-bindings-python</code>来介绍下user态如何利用C和Python来调用iptables的接口获得封包的信息。</p>

<h3>netfilter</h3>

<p>简单地说，netfilter是一套在计算机网络栈中过滤和修改封包的框架，它的做法是在Linux Kernel中插入了一系列的hook，并允许kernel在不同层的网络栈中注册回调函数，这些回调函数会在封包进入相应的hook的时候被调用到。</p>

<!-- more -->


<p>网络栈中对netfilter的支持如图所示：</p>

<p><img src="http://ytliu.info/images/2013-03-29-1.png" title="package flow in netfiter and general networking" alt="netfilter" /></p>

<p>可以看到在链路层和网络层中按照封包流的路径有五种类型的hooks: prerouting, input, forward, output, postrouting。这五种hooks会在封包到达之时按照封包流的顺序调用相应的回调函数，对四种类型的表中的chain（会在iptables中描述）进行过滤和修改：filter, nat, mangle, raw。而定义这些过滤的规则则是由一个用户态的命令<code>iptables</code>进行配置，也就是我接下来要详细描述的命令。</p>

<h3>iptables</h3>

<p><a href="http://itzone.hk/article/index.php?tid=14">这里</a>有6篇系列的文章介绍iptables的，讲的挺清楚，蛮适合入门学习的。</p>

<p>前面说过iptables有四种类型的表：filter，nat，mangle，raw，这里只是对filter表进行介绍：</p>

<p>filter表主要用于对封包进行过滤，在该表中有三条默认的chain：INPUT，FORWARD，OUTPUT。</p>

<p>chain是做什么的呢？(转自<a href="http://itzone.hk/article/article.php?aid=200502091507054036">这里</a>)</p>

<blockquote><p>所謂chain就是一組封包過濾規則，您可以在INPUT chain中加入一條防止所有外界封包進入的規則；您可以在OUTPUT chain中加入一條防止用戶連接某網頁伺服器。準備進入網絡的封包，會順著chain內的過濾規則被稽核，若果該封包並不符合任何規則，則會直接進入網 內，因為INPUT和OUTPUT在Linux kernel裡被預設為ACCEPT，而FORWARD則被預設為DROP。</p></blockquote>

<p>比如说，如果要把发到某个地址（如192.168.1.2）的包丢弃，可以这样做：</p>

<pre><code>$ sudo iptables -A OUTPUT -d 192.168.1.2 -j DROP
</code></pre>

<p>这里<code>-A</code>指对OUTPUT这条链的规则进行修改，<code>-d</code>表示这个封包的destination，<code>-j</code>后加的是target，有五种选择：ACCEPT（不作任何操作，让封包流过），DROP（将封包丢弃），QUEUE（将封包插入队列，传递到用户态处理，这个会在第二篇中详细描述），RETURN（直接从该chain中返回，到前一个chain的下一条规则继续执行），以及自己定义的CHAIN，如下：</p>

<pre><code>$ sudo iptables -N SELF_CHAIN
</code></pre>

<p>也就是说我们可以按照不同的源地址、目标地址、端口、协议等规则分类，由不同的chain进行处理，可以更合理地对过滤条件进行管理。</p>

<p>另外，有几个常用的选项这里提一下：</p>

<pre><code>-A chain                # modify a chain
-D chain rulenum        # delete a specific rule of chain
-I chain rulenum rule   # insert rule in rulenum of chain
-R chain rulenum rule   # replace rule with rulenum of chain
-L [chain]              # list rules of chain
-F [chain]              # flush the rules of chain
-N chain                # new a chain
-X [chain]              # delete chain

-p protocol             # e.g., tcp, udp, icmp...
-s source address       # e.g., 192.168.1.22
-d destination address  # e.g., 192.168.1.13
-j target               # e.g., ACCEPT, DROP, RETURN, QUEUE, other-chain
-i in-interface         # e.g., eth0
-o out-interface        # e.g., eth0
</code></pre>

<hr />

<p>下一篇主要介绍当<code>iptables</code>的target是QUEUE或者NFQUEUE时，用户态要如何调用相关接口。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cross Reference Graph of Android Component]]></title>
    <link href="http://ytliu.github.com/blog/2013/03/24/cross-reference-graph-of-android-component/"/>
    <updated>2013-03-24T13:35:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/03/24/cross-reference-graph-of-android-component</id>
    <content type="html"><![CDATA[<p>由于项目的需要，这周写了一个ruby project——<a href="https://github.com/ytliu/apk-static-xref">apk-static-xref</a>。</p>

<p>虽然现在Android静态分析的项目很多，但是我都没有找到一个看上去很简单的功能：给定一个component，找出它所有调用到的函数，然后画出call graph。</p>

<p>现在的大部分call graph都只能限制在一个class文件里，这里所说的cross reference graph (XRG)就是指函数调用是跨class文件的，需要cross reference直到调用的是Android本身的API或者Java API。</p>

<p>这其实是一个很简单的功能，但我不知道为什么一直找不到工具可以满足我的需求，直到找到了spark的一个<a href="http://appsrv.cse.cuhk.edu.hk/~mzheng/DroidTrace.pdf">slide</a>，里面提到一个cross reference graph。其实就是一个对smali文件的DFS算法。</p>

<!-- more -->


<p>于是我把<a href="">smali-cfg</a>和<a href="">redexer</a>结合了一下，写了这个ruby project，具体做法就是：</p>

<ul>
<li><p>用apktool unpack apk：</p>

<p>  $ java -jar apktool.jar -d source.apk target.dir</p></li>
<li><p>用nokogiri parse AndroidManefest.xml 找出所有的service和activity：</p>

<p>  Nokogiri::XML(f)</p></li>
<li><p>用DFS遍历所有的smali文件，得出整个call graph的结点和边：</p></li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">run_assign</span><span class="p">(</span><span class="n">apk</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="n">mtd</span><span class="p">,</span> <span class="n">pty</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">ori_cls</span><span class="p">)</span>
</span><span class='line'>  <span class="n">match</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>  <span class="nb">caller</span> <span class="o">=</span> <span class="kp">nil</span>
</span><span class='line'>  <span class="n">callee</span> <span class="o">=</span> <span class="kp">nil</span>
</span><span class='line'>  <span class="n">vclass</span> <span class="o">=</span> <span class="kp">nil</span>
</span><span class='line'>  <span class="n">filename</span> <span class="o">=</span> <span class="n">apk</span><span class="o">.</span><span class="n">smali</span> <span class="o">+</span> <span class="n">cls</span> <span class="o">+</span> <span class="s2">&quot;.smali&quot;</span>
</span><span class='line'>  <span class="k">if</span> <span class="no">File</span><span class="o">.</span><span class="n">file?</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</span><span class='line'>    <span class="n">fh</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="k">return</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="n">lines</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">readlines</span>
</span><span class='line'>  <span class="n">lines</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">line</span><span class="o">|</span>
</span><span class='line'>    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">-</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">start_with?</span><span class="p">(</span><span class="s2">&quot;.class&quot;</span><span class="p">)</span>
</span><span class='line'>      <span class="n">vclass</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">[-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">-</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'>    <span class="k">elsif</span> <span class="n">line</span><span class="o">.</span><span class="n">start_with?</span><span class="p">(</span><span class="s2">&quot;.method&quot;</span><span class="p">)</span>
</span><span class='line'>      <span class="nb">caller</span> <span class="o">=</span> <span class="no">Invoker</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">vclass</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="nb">caller</span><span class="o">.</span><span class="n">mtd</span><span class="o">.</span><span class="n">eql?</span><span class="p">(</span><span class="n">mtd</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">caller</span><span class="o">.</span><span class="n">pty</span><span class="o">.</span><span class="n">eql?</span><span class="p">(</span><span class="n">pty</span><span class="p">))</span>
</span><span class='line'>        <span class="n">match</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">elsif</span> <span class="n">line</span><span class="o">.</span><span class="n">start_with?</span><span class="p">(</span><span class="s2">&quot;.end method&quot;</span><span class="p">)</span>
</span><span class='line'>      <span class="n">match</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="k">elsif</span> <span class="n">line</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="s2">&quot;invoke-&quot;</span><span class="p">)</span>
</span><span class='line'>      <span class="n">callee</span> <span class="o">=</span> <span class="no">Invoked</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">match</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="vg">$caller_methods</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="n">callee</span><span class="o">.</span><span class="n">str</span><span class="p">)</span>
</span><span class='line'>          <span class="k">if</span> <span class="o">!</span><span class="vg">$caller_methods</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="nb">caller</span><span class="o">.</span><span class="n">str</span><span class="p">)</span>
</span><span class='line'>            <span class="n">addNodes</span><span class="p">(</span><span class="nb">caller</span><span class="o">.</span><span class="n">str</span><span class="p">,</span> <span class="n">callee</span><span class="o">.</span><span class="n">str</span><span class="p">)</span> <span class="k">if</span> <span class="vg">$graph_need</span>
</span><span class='line'>          <span class="k">end</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>          <span class="n">addNodes</span><span class="p">(</span><span class="nb">caller</span><span class="o">.</span><span class="n">str</span><span class="p">,</span> <span class="n">callee</span><span class="o">.</span><span class="n">str</span><span class="p">)</span> <span class="k">if</span> <span class="vg">$graph_need</span>
</span><span class='line'>          <span class="vg">$caller_methods</span> <span class="o">&lt;&lt;</span> <span class="nb">caller</span><span class="o">.</span><span class="n">str</span>
</span><span class='line'>          <span class="n">run_assign</span><span class="p">(</span><span class="n">apk</span><span class="p">,</span> <span class="n">callee</span><span class="o">.</span><span class="n">cls</span><span class="p">,</span> <span class="n">callee</span><span class="o">.</span><span class="n">mtd</span><span class="p">,</span> <span class="n">callee</span><span class="o">.</span><span class="n">pty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ori_cls</span><span class="p">)</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>用ruby-graphviz画出call graph</p>

<p>  $graph.output(:png => &#8220;#{to}.png&#8221;)</p></li>
</ul>


<p>其实整个过程非常的简单，不过可能自己代码写得比较烂，会不太好理解。另外，现在是先用apktool把apk翻译成smali之后再对smali进行操作，效率可能会比较慢，接下来准备把实现改成直接对dex文件进行分析，打算基于Android自带的dexdump或者开源的baksmali，顺便把dex的格式搞得更加清楚一点。</p>

<hr />

<p>由于下周一门课的原因，这周又把OSDI 2012的<a href="http://research.microsoft.com/pubs/173922/appinsight.pdf">AppInsight</a>的论文仔细看了一遍，觉得确实是做得很好很有用的一个系统。我希望自己能把它实现在Android上。其实整个原理也不是非常的难，我想最难的部分在于Windows本来就有一个Detour可以直接利用来做instrumentation和interception，非常的方便，但是Java本身好像没有一个相当的库，需要自己实现一遍。</p>

<p>不知道这个计划需要多久才能完成，我可能要先找个和Detour功能类似的库改一改，希望这个作为自己第一个比较正式的开源项目不会中途破产吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redexer and Ocaml]]></title>
    <link href="http://ytliu.github.com/blog/2013/03/10/redexer-and-ocaml/"/>
    <updated>2013-03-10T09:53:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/03/10/redexer-and-ocaml</id>
    <content type="html"><![CDATA[<p>在<a href="http://ytliu.info/blog/2013/03/01/dr-android-and-mr-hide-xidashiyin-fa-de-gu-shi/">上一篇博客</a>是一个用ruby和OCaml写的Dalvik binary rewriter，它提供了unparse, htmlunparse, id, combine, info, classes, api, opstat, cg, cfg, dom, pdom, dump_method等功能，还可以自己扩展相应的功能，具体的可以参看它的<a href="https://github.com/plum-umd/redexer">github主页</a>。</p>

<p>redexer主要原理就是将<code>.dex</code>文件按照<a href="http://source.android.com/tech/dalvik/dex-format.html">Dalvik Executable Format</a>映射到内存中的数据结构，然后根据这些数据结果进行分析，可以达到比较高的性能。</p>

<p>这里主要想要说说<a href="http://en.wikipedia.org/wiki/OCaml">OCaml</a>这个语言。</p>

<!-- more -->


<p>OCaml的全称是Object Caml，是一个有OO扩展的函数式语言（Functional Language），看了看它的语法，和我们程序语言理论里面的那个simPL非常的像，也和当时学FP的时候讲的Haskell很像。</p>

<p>查了查functional language和imperative language有什么不同，在wiki上似乎有一个最大的区别在于：</p>

<pre><code>It emphasizes the application of functions, in contrast to the imperative programming style, 
which emphasizes changes in state. The most significant differences stem from the fact that 
functional programming avoids side effects, which are used in imperative programming to implement 
state and I/O. 
</code></pre>

<p>然后在<a href="http://stackoverflow.com/questions/2078978/functional-programming-vs-object-oriented-programming">stack overflow</a>里面有一个蛮经典的回答”When do you choose functional programming over object oriented ?“</p>

<p><img src="http://ytliu.info/images/2013-03-10-1.png" title="answer" alt="stackoverflowans" /></p>

<p>另外，在OCaml里面有很多FP的特性，比如 static type system, type inference, parametric polymorphism, tail recursion, pattern matching, first class lexical closures, functors (parametric modules), exception handling, and incremental generational automatic garbage collection等等，这些会在之后对OCaml的学习中慢慢弄清楚来吧~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dr. Android and Mr. Hide - xidashi引发的故事]]></title>
    <link href="http://ytliu.github.com/blog/2013/03/01/dr-android-and-mr-hide-xidashiyin-fa-de-gu-shi/"/>
    <updated>2013-03-01T20:00:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/03/01/dr-android-and-mr-hide-xidashiyin-fa-de-gu-shi</id>
    <content type="html"><![CDATA[<p>故事得从几天前利小哥发现的<a href="www.xidashi.com">xidashi</a>说起：</p>

<p><img src="http://ytliu.info/images/2013-03-01-1.png" title="xidashi" alt="xidashi" /></p>

<p>洗大师是一个android的安全应用软件+第三方应用市场，它的功能和特点简单来说就是：</p>

<blockquote><p>在不root的情况下，允许用户对已安装的应用程序实行权限的细粒度动态控制</p></blockquote>

<p>这里的细粒度动态控制是指用户可以随时允许或禁止该应用程序某一个权限，并对利用该权限调用API的行为进行log。</p>

<p>洗大师的流程是这样子的：</p>

<p>上传apk -> 服务器对apk进行”清洗“ -> 返回”清洗“过后的apk并安装 -> 在apk运行过程中进行动态权限控制</p>

<p>当然还有一种模式就是”直接下载洗大师market提供的应用“。</p>

<!-- more -->


<p>咋一看，这真的是一个非常牛逼的应用，在没有root的情况下可以对每个应用进行细粒度动态权限控制，这样用户就再也不用担心恶意程序利用过渡申请的权限做坏事了！</p>

<p>而且从实现上来看，利小哥刚开始写了一个很简单的测试程序，用洗大师”洗“了洗，发现它就加了一个包，而没有对原来的程序进行任何修改，我们都觉得不可思议！amazing！！！讨论了下觉得这是不可能的，然后斌哥就在网上找到了这一篇文章<a href="http://www.cs.umd.edu/~jfoster/papers/acplib.pdf">Dr. Android and Mr. Hide: Fine-grained security policies on unmodiﬁed Android</a>，这是一篇基于spsm2012的technical report，然后再重新写了个测试程序用洗大师”洗“了洗，发现其实它还是改了应用程序原来的binary的。于是乎，就感觉被骗了一样。不过仔细想来，其实洗大师这种方式不失为一种解决恶意程序权限泛滥的好办法，不知道洗大师的作者是看了这篇论文做出的洗大师还是自己想出来的，这种创业产品还是比较有效的，特别是如果它的第三方市场能够更加普及一点的话。当然啦，我们都觉得这个技术并不是一个高不可攀的技术，对于腾讯、360这种xx公司来说，要实现类似的功能应该还是挺快的。我去关注了下洗大师的新浪微博，发现它现在的粉丝并不多，不知道洗大师最后能牛逼到什么程度，祝君好运吧。</p>

<hr />

<p>扯了那么多闲话，开始进入正题，这一篇《Dr. Android and Mr. Hide》从效果上来说和洗大师还是有一点不同的，但是我觉得实现原理应该不会差太远，这里简单介绍下吧：</p>

<p>它的motivation是这样的：</p>

<p>现在Android的权限系统粒度太粗了，举个例子：如果一个应用程序，比如”大众点评“（点评躺着中枪了），申请了一个INTERNET权限，那么它就可以访问所有的网络了，但是实际上它只需要访问www.dianping.com这一个域名，那么一个恶意程序或者repackage的程序就可以利用它的网络权限窃取一些隐私数据传到某个服务器，这种方式并没有违反Android的权限系统。那么这篇paper的目的就是在不修改Android Framework的情况下将权限细化，比如把INTERNET改成InternetURL(d)，使得有后者权限的应用只能访问<code>d</code>这个URL。</p>

<p>这里需要说明的是，在这种安全防护模式下有两种方法可以做：</p>

<ul>
<li>修改Android Framework，换一种方式，从用户的角度来说也就是root，或者刷机；</li>
<li>对应用程序进行instrumentation，也就是将应用程序改一改，然后repackage一下。当然这个步骤应该是可以自动化的。</li>
</ul>


<p>对于前者来说，需要google或者一些设备提供商的支持，或者用户进行root；对于后者来说，谁来进行instrumentation，instrumentation产生的side effect都是需要考虑的问题。</p>

<p>这篇文章采用了第二种方式，而它的方法其实是很直观的：</p>

<p><img src="http://ytliu.info/images/2013-03-01-2.png" title="Mr. Hide" alt="mrhide" /></p>

<p><img src="http://ytliu.info/images/2013-03-01-3.png" title="Dr. Android" alt="drandroid" /></p>

<ul>
<li>首先，将apk中的粗粒度权限换成细粒度权限；</li>
<li>然后在apk中插入一个library（文中为hidelib），并通过一个自动化工具Dr. Android找出应用程序中所有对sensitive API的调用，将其换成hidelib中对应的API调用；</li>
<li>hidelib中的API会首先对应用的权限进行一个检查，然后和Mr. Hide进行交互，Mr. Hide是一个运行在另一个进程中的Service，它可以根据hidelib传送过来的信息进行相应的调用，并将结果返回。</li>
</ul>


<p>当然，这里面会牵扯到很多细节问题，比如应用程序怎么样和Mr. Hide进行binding，如何保护Mr. Hide不被恶意程序利用，以及如何精确而又高效地对原始apk进行instrumentation，还有很多Android中签名机制的问题等等，这里就不一一阐述了。</p>

<hr />

<p>值得一提的是，这篇paper中提到的Dr. Android是一个叫做<a href="http://www.cs.umd.edu/projects/PL/redexer/about.html">redexer</a>的开源项目，也就是作者开发的。redexer是一个用ruby和OCaml写的Dalvik Binary Rewriter，效率很高，功能也挺强大的。我在之后的博客中会对其进行一个介绍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Traceview in Android]]></title>
    <link href="http://ytliu.github.com/blog/2013/02/23/traceview-in-android/"/>
    <updated>2013-02-23T15:54:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/02/23/traceview-in-android</id>
    <content type="html"><![CDATA[<p>这两天尝试了下用Android自带的<a href="http://developer.android.com/tools/debugging/debugging-tracing.html">Traceview</a>进行profile，感觉蛮有意思的，而且发现它的文档上对数据格式的说明和我实现时候碰到的情况有出入，于是在google code上发了封<a href="https://code.google.com/p/android/issues/detail?id=51286">帖</a>（<a href="https://code.google.com/p/android/issues/detail?id=50930#makechanges">前一封</a>被华丽丽地无视掉了），但是到最后还是不明白到底是什么问题，维护文档的人好不热情啊&#8230;</p>

<p>反正这里还是按照我的实验情况来解释吧:-)</p>

<!-- more -->


<p>首先得解释下什么是Traceview。最简单而且最普遍的Traceview的流程是这样子的：</p>

<ul>
<li>用户首先要对源代码进行一些instrumentation，如下所示：</li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'> <span class="c1">// start tracing to &quot;/sdcard/calc.trace&quot;</span>
</span><span class='line'>    <span class="n">Debug</span><span class="o">.</span><span class="na">startMethodTracing</span><span class="o">(</span><span class="s">&quot;calc&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="c1">// stop tracing</span>
</span><span class='line'>    <span class="n">Debug</span><span class="o">.</span><span class="na">stopMethodTracing</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>之后当运行到<code>Debug.startMethodTracing</code>时，系统就会进入Trace模式，在<code>/sdcard</code>目录下创建一个<code>calc.trace</code>文件，并动态地将之后的所有函数调用都trace进这个文件中（当然也包括framework中的API调用）；</li>
<li>然后就可以利用Android提供的Traceview工具或者dmtracedump工具对这个文件进行分析了。</li>
</ul>


<p>其中通过Traceview可以获得很多非常有用的信息，包括Timeline Panel和Profile Panel，具体的可以参见Traceview的<a href="http://developer.android.com/tools/debugging/debugging-tracing.html">document</a>，这里就不阐述了。而通过dmtracedump工具可以得到整个运行过程中的call-stack diagram。</p>

<p>不过目前的dmtracedump的call-graph功能还没有实现，于是我从网上找到一个用python脚本写的<a href="http://blog.csdn.net/zjujoe/article/details/6080738">dmtracedump替代</a>，一开始不能用，于是debug了一通，从而发现了前面说的和Traceview官方文档的出入。下面主要就是解释一下有何出入：</p>

<p>首先要介绍下官方文档中由Debug产生的Traceview的文件格式是怎样的：</p>

<p>cal.trace主要分为两个部分 —— key和data。</p>

<p>key部分的格式是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*version
</span><span class='line'>1
</span><span class='line'>clock=global
</span><span class='line'>*threads
</span><span class='line'>1 main
</span><span class='line'>6 JDWP Handler
</span><span class='line'>5 Async GC
</span><span class='line'>4 Reference Handler
</span><span class='line'>3 Finalizer
</span><span class='line'>2 Signal Handler
</span><span class='line'>*methods
</span><span class='line'>0x080f23f8 java/io/PrintStream write ([BII)V
</span><span class='line'>0x080f25d4 java/io/PrintStream print (Ljava/lang/String;)V
</span><span class='line'>0x080f27f4 java/io/PrintStream println (Ljava/lang/String;)V
</span><span class='line'>0x080da620 java/lang/RuntimeException   &lt;init>    ()V
</span><span class='line'>[...]
</span><span class='line'>0x080f630c android/os/Debug startMethodTracing ()V
</span><span class='line'>0x080f6350 android/os/Debug startMethodTracing (Ljava/lang/String;Ljava/lang/String;I)V
</span><span class='line'>*end</span></code></pre></td></tr></table></div></figure>


<p>它分为了3个sections，每一个section由<code>*</code>开头：</p>

<ul>
<li>version section;</li>
<li>threads section：主要记录了thread ID和thread Name，其中thread ID会在data部分中被引用；</li>
<li>methods section：主要记录了method ID和method signature，其中method ID用于被data部分的record引用。</li>
</ul>


<p>data部分的格式是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>* File format:
</span><span class='line'>* header
</span><span class='line'>* record 0
</span><span class='line'>* record 1
</span><span class='line'>* ...
</span><span class='line'>*
</span><span class='line'>* Header format:
</span><span class='line'>* u4 magic 0x574f4c53 ('SLOW')
</span><span class='line'>* u2 version
</span><span class='line'>* u2 offset to data
</span><span class='line'>* u8 start date/time in usec
</span><span class='line'>*
</span><span class='line'>* Record format:
</span><span class='line'>* u1 thread ID
</span><span class='line'>* u4 method ID | method action
</span><span class='line'>* u4 time delta since start, in usec</span></code></pre></td></tr></table></div></figure>


<p>它由heade和一系列的records组成，其中在header里面有一个域叫offset to data，由此可以找到第一个record的地址，而每一个record由三部分组成：</p>

<ul>
<li>thread ID：就是在key里面的那个thread ID；</li>
<li>method ID | method action：就是在key里面的那个method ID，method action有四种情况: {0->method entry; 1->method exit; 2->method exited by exception handling; 3->reversed};</li>
<li>time：就是这个action发生的时间，正常情况下时间都是按照升序排序的。</li>
</ul>


<p>有了这个trace文件以及事先协议好的格式，就可以进行分析了。即对每一个record进行遍历，得到每个时间点的函数调用，并将它们串起来，就可以得到很多信息。</p>

<p>但是在我的实验中，发现data部分中每个record不是像文档中描述的那样是由9个bytes组成的，而是14个bytes组成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>* Record format:
</span><span class='line'>* u2 thread ID
</span><span class='line'>* u4 method ID | method action
</span><span class='line'>* u8 time delta since start, in usec</span></code></pre></td></tr></table></div></figure>


<p>我的猜想是和产生trace文件时机器的配置有关，我的系统是Debian 6.0，x86_64，维护文档的人似乎没有回答我，不过根据后面一个回答，好像确实在新的版本中就是14个bytes。</p>

<p>Anyway，不管怎么样，这个trace文件是可以提供非常多动态信息的，但是需要对源代码进行修改，并且可能会产生比较大的运行时overhead（自己猜的，没有验证）。不过按照文档上的说法还有一种方式是采用<a href="http://developer.android.com/tools/debugging/ddms.html">DDMS</a>，不过我也没有尝试过，就不在这里阐述了。</p>

<hr />

<p>另外，Python脚本我就不帖出来了，我用ruby重新实现了一遍，这是可以在我的机器上work的版本：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># dmtracedump.rb</span>
</span><span class='line'><span class="c1"># turn the traceview data into a png pic, showing methods call relationship</span>
</span><span class='line'>
</span><span class='line'><span class="c1">################################################################################</span>
</span><span class='line'><span class="c1">########################  Global Variable  #####################################</span>
</span><span class='line'><span class="c1">################################################################################</span>
</span><span class='line'><span class="vi">@target_thread</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'><span class="vi">@all_threads</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'><span class="vi">@all_methods</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'><span class="vi">@all_records</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'><span class="vi">@parent_methods</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'><span class="vi">@child_methods</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'><span class="vi">@method_calls</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">################################################################################</span>
</span><span class='line'><span class="c1">##############################   Methods   #####################################</span>
</span><span class='line'><span class="c1">################################################################################</span>
</span><span class='line'><span class="k">def</span> <span class="nf">add_one_thread</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</span><span class='line'>    <span class="n">fields</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="vi">@all_threads</span><span class="o">[</span><span class="n">fields</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">to_i</span><span class="o">]=</span><span class="n">fields</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">add_one_method</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</span><span class='line'>    <span class="n">fields</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="vi">@all_methods</span><span class="o">[</span><span class="n">fields</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">to_i</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">]=</span><span class="n">fields</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">add_one_record</span><span class="p">(</span><span class="n">one</span><span class="p">)</span>
</span><span class='line'>    <span class="n">record</span> <span class="o">=</span> <span class="n">one</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;SLQ&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">record</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="vi">@target_thread</span>
</span><span class='line'>        <span class="n">method_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">record</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span>
</span><span class='line'>        <span class="n">method_action</span> <span class="o">=</span> <span class="n">record</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">%</span> <span class="mi">4</span>
</span><span class='line'>        <span class="vi">@all_records</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="o">[</span><span class="n">record</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">,</span> <span class="n">method_id</span><span class="p">,</span> <span class="n">method_action</span><span class="p">,</span> <span class="n">record</span><span class="o">[</span><span class="mi">2</span><span class="o">]]</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">handle_one_call</span><span class="p">(</span><span class="n">parent_method_id</span><span class="p">,</span> <span class="n">method_id</span><span class="p">)</span>
</span><span class='line'>    <span class="c1"># p &quot;#{parent_method_id} -&gt; #{method_id}&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="o">!</span><span class="vi">@parent_methods</span><span class="o">.</span><span class="n">has_key?</span><span class="p">(</span><span class="n">parent_method_id</span><span class="p">)</span>
</span><span class='line'>        <span class="vi">@parent_methods</span><span class="o">[</span><span class="n">parent_method_id</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span>  <span class="o">!</span><span class="vi">@child_methods</span><span class="o">.</span><span class="n">has_key?</span><span class="p">(</span><span class="n">method_id</span><span class="p">)</span>
</span><span class='line'>        <span class="vi">@child_methods</span><span class="o">[</span><span class="n">method_id</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="vi">@method_calls</span><span class="o">.</span><span class="n">has_key?</span><span class="p">(</span><span class="n">parent_method_id</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="vi">@method_calls</span><span class="o">[</span><span class="n">parent_method_id</span><span class="o">].</span><span class="n">has_key?</span><span class="p">(</span><span class="n">method_id</span><span class="p">)</span>
</span><span class='line'>            <span class="vi">@method_calls</span><span class="o">[</span><span class="n">parent_method_id</span><span class="o">][</span><span class="n">method_id</span><span class="o">]</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>            <span class="vi">@method_calls</span><span class="o">[</span><span class="n">parent_method_id</span><span class="o">][</span><span class="n">method_id</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>        <span class="vi">@method_calls</span><span class="o">[</span><span class="n">parent_method_id</span><span class="o">]</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'>        <span class="vi">@method_calls</span><span class="o">[</span><span class="n">parent_method_id</span><span class="o">][</span><span class="n">method_id</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">gen_funcname</span><span class="p">(</span><span class="n">method_id</span><span class="p">)</span>
</span><span class='line'>    <span class="n">cla_med</span> <span class="o">=</span> <span class="vi">@all_methods</span><span class="o">[</span><span class="n">method_id</span><span class="o">][</span><span class="mi">1</span><span class="o">].</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/[\/\$&lt;&gt;]/</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">sub_med</span> <span class="o">=</span> <span class="vi">@all_methods</span><span class="o">[</span><span class="n">method_id</span><span class="o">][</span><span class="mi">2</span><span class="o">].</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/[\/\$&lt;&gt;]/</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="s2">&quot;</span><span class="si">#{</span><span class="n">cla_med</span><span class="si">}</span><span class="s2">_</span><span class="si">#{</span><span class="n">sub_med</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">gen_dot_script_file</span>
</span><span class='line'>    <span class="n">ofile</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;graph.dot&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">ofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;digraph vanzo {</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="vi">@all_methods</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
</span><span class='line'>        <span class="k">if</span> <span class="vi">@parent_methods</span><span class="o">.</span><span class="n">has_key?</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</span><span class='line'>            <span class="n">ofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">gen_funcname</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="si">}</span><span class="s2">  [shape=rectangle];</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>            <span class="k">if</span> <span class="vi">@child_methods</span><span class="o">.</span><span class="n">has_key?</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</span><span class='line'>                <span class="n">ofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">gen_funcname</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="si">}</span><span class="s2">  [shape=ellipse];</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="k">end</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="vi">@method_calls</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
</span><span class='line'>        <span class="vi">@method_calls</span><span class="o">[</span><span class="nb">p</span><span class="o">].</span><span class="n">keys</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span>
</span><span class='line'>          <span class="n">ofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">gen_funcname</span><span class="p">(</span><span class="nb">p</span><span class="p">)</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">#{</span><span class="n">gen_funcname</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="si">}</span><span class="s2"> [label=&#39;</span><span class="si">#{</span><span class="vi">@method_calls</span><span class="o">[</span><span class="nb">p</span><span class="o">][</span><span class="n">c</span><span class="o">].</span><span class="n">to_s</span><span class="si">}</span><span class="s2">&#39; fontsize=&#39;10&#39;];</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">ofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">ofile</span><span class="o">.</span><span class="n">close</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1">################################################################################</span>
</span><span class='line'><span class="c1">########################## Script starts from here #############################</span>
</span><span class='line'><span class="c1">################################################################################</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="no">ARGV</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span>
</span><span class='line'>    <span class="nb">print</span> <span class="s2">&quot;No input file specified.&quot;</span>
</span><span class='line'>    <span class="nb">exit</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="o">!</span><span class="no">File</span><span class="o">.</span><span class="n">exists?</span><span class="p">(</span><span class="no">ARGV</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">p</span> <span class="s2">&quot;input file not exists&quot;</span>
</span><span class='line'>    <span class="nb">exit</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1">#Now handle the text part</span>
</span><span class='line'><span class="n">current_section</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="n">lines</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">readlines</span><span class="p">(</span><span class="no">ARGV</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'><span class="n">lines</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">line</span><span class="o">|</span>
</span><span class='line'>  <span class="n">line</span><span class="o">.</span><span class="n">strip!</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">start_with?</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">start_with?</span><span class="p">(</span><span class="s2">&quot;*version&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">current_section</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>        <span class="k">elsif</span> <span class="n">line</span><span class="o">.</span><span class="n">start_with?</span><span class="p">(</span><span class="s2">&quot;*threads&quot;</span><span class="p">)</span>
</span><span class='line'>          <span class="n">current_section</span> <span class="o">=</span> <span class="mi">2</span>
</span><span class='line'>        <span class="k">elsif</span> <span class="n">line</span><span class="o">.</span><span class="n">start_with?</span><span class="p">(</span><span class="s2">&quot;*methods&quot;</span><span class="p">)</span>
</span><span class='line'>          <span class="n">current_section</span> <span class="o">=</span> <span class="mi">3</span>
</span><span class='line'>      <span class="k">elsif</span> <span class="n">line</span><span class="o">.</span><span class="n">start_with?</span><span class="p">(</span><span class="s2">&quot;*end&quot;</span><span class="p">)</span>
</span><span class='line'>          <span class="n">current_section</span> <span class="o">=</span> <span class="mi">4</span>
</span><span class='line'>          <span class="k">break</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">elsif</span> <span class="n">current_section</span> <span class="o">==</span> <span class="mi">2</span>
</span><span class='line'>        <span class="n">add_one_thread</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</span><span class='line'>    <span class="k">elsif</span> <span class="n">current_section</span> <span class="o">==</span> <span class="mi">3</span>
</span><span class='line'>        <span class="n">add_one_method</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">#Now handle the binary part</span>
</span><span class='line'><span class="n">file</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="no">ARGV</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">alldata</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</span><span class='line'><span class="c1">#alldata = File.read(ARGV[0])</span>
</span><span class='line'><span class="n">pos</span> <span class="o">=</span> <span class="n">alldata</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;SLOW&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">offset</span> <span class="o">=</span> <span class="n">alldata</span><span class="o">[</span><span class="n">pos</span><span class="o">+</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="o">].</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</span><span class='line'><span class="n">pos</span> <span class="o">+=</span> <span class="n">offset</span> <span class="c1">#where the record begin</span>
</span><span class='line'><span class="n">record_num</span> <span class="o">=</span> <span class="n">alldata</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">pos</span>
</span><span class='line'><span class="n">record_num</span> <span class="o">/=</span> <span class="mi">14</span>
</span><span class='line'><span class="mi">0</span><span class="o">.</span><span class="n">upto</span><span class="p">(</span><span class="n">record_num</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
</span><span class='line'>  <span class="n">add_one_record</span><span class="p">(</span><span class="n">alldata</span><span class="o">[</span><span class="n">pos</span><span class="o">+</span><span class="n">i</span><span class="o">*</span><span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">my_stack</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="vi">@all_records</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">onerecord</span><span class="o">|</span>
</span><span class='line'>  <span class="n">thread_id</span> <span class="o">=</span> <span class="n">onerecord</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="n">method_id</span> <span class="o">=</span> <span class="n">onerecord</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="n">action</span> <span class="o">=</span> <span class="n">onerecord</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="n">time</span> <span class="o">=</span> <span class="n">onerecord</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">my_stack</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span>
</span><span class='line'>            <span class="n">parent_method_id</span> <span class="o">=</span> <span class="n">my_stack</span><span class="o">[-</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'>            <span class="n">handle_one_call</span><span class="p">(</span><span class="n">parent_method_id</span><span class="p">,</span> <span class="n">method_id</span><span class="p">)</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>        <span class="n">my_stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">method_id</span><span class="p">)</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="mi">1</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">my_stack</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span>
</span><span class='line'>                <span class="n">my_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</span><span class='line'>            <span class="k">end</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">gen_dot_script_file</span>
</span><span class='line'><span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;dot -Tjpg graph.dot -o output.png;rm -f graph.dot&quot;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>用法：</p>

<pre><code>$ ruby dmtracedump.rb calc.trace
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【转】计算机的启动]]></title>
    <link href="http://ytliu.github.com/blog/2013/02/17/%5B%28zhuan-%29%5D-ji-suan-ji-de-qi-dong/"/>
    <updated>2013-02-17T14:24:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/02/17/[(zhuan-)]-ji-suan-ji-de-qi-dong</id>
    <content type="html"><![CDATA[<p>寒假回来就要开始执行新年的计划了~首先是每周的一篇blog。</p>

<p>今天看了<a href="http://www.ruanyifeng.com/blog/">阮一峰</a>最新的一篇博客<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的</a>，感觉写得很好，又清楚又简单。虽然自己关于计算机启动这个过程从大三OS课的时候就陆陆续续地一直有了解，但是都没有一个系统的了解，或者了解了又忘了，希望通过这次记录把这点彻底弄清楚来并且记在脑子里。另外在评论中有另外一个小哥<a href="http://www.dalei.org/">大磊</a>把他的<a href="http://www.dalei.org/linux-unix-boot-process/">博客</a>也贴出来了，写得很详细，作为阮一峰的补充吧。</p>

<!-- more -->


<hr />

<p>以下是转来的文章，中间加上了大磊的补充，也没有区分哪句话是谁说的，具体的还是看之前提到的两篇博客吧：</p>

<h4>零、boot的含义</h4>

<p>先问一个问题，&#8221;启动&#8221;用英语怎么说？</p>

<p>回答是boot。可是，boot原来的意思是靴子，&#8221;启动&#8221;与靴子有什么关系呢？ 原来，这里的boot是bootstrap（鞋带）的缩写，它来自一句谚语：</p>

<pre><code>"pull oneself up by one's bootstraps"
</code></pre>

<p>字面意思是&#8221;拽着鞋带把自己拉起来&#8221;，这当然是不可能的事情。最早的时候，工程师们用它来比喻，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！</p>

<p>早期真的是这样，必须想尽各种办法，把一小段程序装进内存，然后计算机才能正常运行。所以，工程师们把这个过程叫做&#8221;拉鞋带&#8221;，久而久之就简称为boot了。</p>

<p>计算机的整个启动过程分成四个阶段。</p>

<h4>一、第一阶段：BIOS</h4>

<p>上个世纪70年代初，&#8221;只读内存&#8221;（read-only memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。</p>

<p><img src="http://ytliu.info/images/2013-02-17-1.png" title="BIOS" alt="BIOS" /></p>

<p>这块芯片里的程序叫做&#8221;基本輸出輸入系統&#8221;（Basic Input/Output System），简称为BIOS。</p>

<h5>1.1 硬件自检</h5>

<p>BIOS中主要存放的程序包括：自诊断程序（通过读取CMOS RAM中的内容识别硬件配置，并对其进行自检和初始化）、CMOS设置程序（引导过程中，通过特殊热键启动，进行设置后，存入CMOS RAM中）、系统自动装载程序（在系统自检成功后，将磁盘相对0道0扇区上的引导程序装入内存使其运行）和主要I/O驱动程序和中断服务（BIOS和硬件直接打交道，需要加载I/O驱动程序）。</p>

<p>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做&#8221;硬件自检&#8221;（Power-On Self-Test），缩写为POST。</p>

<p>如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</p>

<h5>1.2 启动顺序</h5>

<p>硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。</p>

<p>这时，BIOS需要知道，&#8221;下一阶段的启动程序&#8221;具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做&#8221;启动顺序&#8221;（Boot Sequence）。</p>

<p>打开BIOS的操作界面，里面有一项就是&#8221;设定启动顺序&#8221;。</p>

<p><img src="http://ytliu.info/images/2013-02-17-2.png" title="BIOS Sequence" alt="BIOS Sequence" /></p>

<h4>二、第二阶段：主引导记录</h4>

<p>BIOS按照&#8221;启动顺序&#8221;，把控制权转交给排在第一位的储存设备。即根据用户指定的引导顺序从软盘、硬盘或是可移动设备中读取启动设备的MBR，并放入指定的位置（0x7c000）内存中。</p>

<p>这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给&#8221;启动顺序&#8221;中的下一个设备。</p>

<p>这最前面的512个字节，就叫做&#8221;主引导记录&#8221;（Master boot record，缩写为MBR）。</p>

<h5>2.1 主引导记录的结构</h5>

<p>&#8220;主引导记录&#8221;只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。</p>

<p>主引导记录由三个部分组成：</p>

<pre><code>（1） 第1-446字节：调用操作系统的机器码。
（2） 第447-510字节：分区表（Partition table）。
（3） 第511-512字节：主引导记录签名（0x55和0xAA）。
</code></pre>

<p>其中，第二部分&#8221;分区表&#8221;的作用，是将硬盘分成若干个区。</p>

<h5>2.2 分区表</h5>

<p>硬盘分区有很多好处。考虑到每个区可以安装不同的操作系统，&#8221;主引导记录&#8221;因此必须知道将控制权转交给哪个区。</p>

<p>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做&#8221;主分区&#8221;。</p>

<p>每个主分区的16个字节，由6个部分组成：</p>

<pre><code>（1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。
（2） 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。
（3） 第5个字节：主分区类型。
（4） 第6-8个字节：主分区最后一个扇区的物理位置。
（5） 第9-12字节：该主分区第一个扇区的逻辑地址。
（6） 第13-16字节：主分区的扇区总数。
</code></pre>

<p>最后的四个字节（&#8221;主分区的扇区总数&#8221;），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。</p>

<p>如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。</p>

<h4>三、第三阶段：硬盘启动</h4>

<p>这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。</p>

<h5>3.1 情况A：卷引导记录</h5>

<p>上一节提到，四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做&#8221;卷引导记录&#8221;（Volume boot record，缩写为VBR）。</p>

<p>&#8220;卷引导记录&#8221;的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。</p>

<h5>3.2 情况B：扩展分区和逻辑分区</h5>

<p>随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成&#8221;扩展分区&#8221;（Extended partition）。</p>

<p>所谓&#8221;扩展分区&#8221;，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做&#8221;逻辑分区&#8221;（logical partition）。</p>

<p>计算机先读取扩展分区的第一个扇区，叫做&#8221;扩展引导记录&#8221;（Extended boot record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。</p>

<p>计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。</p>

<p>但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。</p>

<h5>3.3 情况C：启动管理器</h5>

<p>在这种情况下，计算机读取&#8221;主引导记录&#8221;前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的&#8221;启动管理器&#8221;（boot loader），由用户选择启动哪一个操作系统。</p>

<p>Linux环境中，目前最流行的启动管理器是Grub。</p>

<p><img src="http://ytliu.info/images/2013-02-17-3.png" title="Grub" alt="Grub" /></p>

<p>对于grub而言，在MBR中的446字节的引导程序属于GRUB的开始执行程序，通过这段程序，进一步执行stage1.5或是stage2的执行程序，将在下面详细介绍执行过程。</p>

<p>其中stage1.5或是stage2便属于阶段2引导的过程了，stage2过程也是作为GRUB kernel的核心代码出现。Stage1.5过程（对于GRUB而言存在stage1.5，GRUB2则不存在）的功能很单一，主要就是为了引导stage2过程服务。由于stage2过程的代码存放在文件系统下的boot分区目录中，因此stage1.5过程就是需要提供一个文件系统的环境，而该文件系统环境需要保证系统可以找到stage2过程的文件，那么stage1.5阶段提供的文件系统需要是boot文件系统所对应的，这个在执行grub install过程中就已经确定了。stage2过程中，主要会把系统切换到保护模式，设置好C运行时环境，找到config文件（事实上就是menulist文件），如果没有找到就执行一个shell，等待用户的执行。然后的工作就变成了输入命令->解析命令->执行命令的循环中。当然该阶段引导的最终状态就是执行boot命令，将内核和initrd镜像加载进入内存中，进而将控制权转交给内核。</p>

<h4>四、第四阶段：操作系统</h4>

<p>控制权转交给操作系统后，操作系统的内核首先被载入内存。</p>

<p>以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。</p>

<p>然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。</p>

<p>至此，全部启动过程完成。</p>

<hr />

<p>另外在大磊的<a href="http://www.dalei.org/linux-unix-boot-process/">博客</a>中还有许多细节部分：</p>

<h4>BIOS启动细节：</h4>

<p>a) 按下电源开关，电源就开始向主板和其它设备供电；当芯片组检测到电源已经开始稳定供电了(当然从不稳定到稳定的过程只是一瞬间的事情)，它便撤去RESET信号(如果是手工按下计算机面板上的Reset按钮来重启机器，那么松开该按钮时芯片组就会撤去RESET信号)；CPU马上就从地址FFFF:0000H 处开始执行指令，放在这里的只是一条跳转指令，跳到系统BIOS中真正的启动代码处。</p>

<p>b) 系统BIOS的启动代码首先进行POST(Power－On Self Test，加电后自检)。POST的主要检测系统中一些关键设备是否存在和能否正常工作，例如内存和显卡等设备；由于POST是最早进行的检测过程，此时显卡还没有初始化，如果系统BIOS在进行POST的过程中发现了一些致命错误，例如没有找到内存或者内存有问题(此时只会检查640K常规内存)，那么系统BIOS就会直接控制喇叭发声来报告错误，声音的长短和次数代表了错误的类型；在正常情况下，POST过程进行得非常快，几乎无法感觉到它的存在。POST结束之后就会调用其它代码来进行更完整的硬件检测。</p>

<p>c) 接下来系统BIOS将查找显卡的BIOS。前面说过，存放显卡BIOS的ROM芯片的起始地址通常设在C0000H处，系统BIOS在这个地方找到显卡BIOS之后就调用它的初始化代码，由显卡BIOS来初始化显卡。此时多数显卡都会在屏幕上显示出一些初始化信息，介绍生产厂商、图形芯片类型等内容，不过这个画面几乎是一闪而过。系统BIOS接着会查找其它设备的BIOS程序，找到之后同样要调用这些BIOS内部的初始化代码来初始化相关的设备。</p>

<p>d) 查找完所有其它设备的BIOS之后，系统BIOS将显示出它自己的启动画面，其中包括有系统BIOS的类型、序列号和版本号等内容。</p>

<p>e) 接着系统BIOS将检测和显示CPU的类型和工作频率，测试所有的RAM，并同时在屏幕上显示内存测试的进度。可以在CMOS设置中自行决定使用简单耗时少或者详细耗时多的测试方式。</p>

<p>f) 内存测试通过之后，系统BIOS将开始检测系统中安装的一些标准硬件设备，包括硬盘、CD-ROM、串口、并口和软驱等设备，另外绝大多数较新版本的系统BIOS在这一过程中还要自动检测和设置内存的定时参数、硬盘参数和访问模式等。</p>

<p>g) 标准设备检测完毕后，系统BIOS内部支持即插即用的代码将开始检测和配置系统中安装的即插即用设备。每找到一个设备之后，系统BIOS都会在屏幕上显示出设备的名称和型号等信息，同时为该设备分配中断、DMA通道和I/O端口等资源。</p>

<p>h) 到这一步为止，所有硬件都已经检测配置完毕了，多数系统BIOS会重新清屏并在屏幕上方显示出一个表格，其中概略地列出了系统中安装的各种标准硬件设备，以及它们使用的资源和一些相关工作参数。</p>

<p>i) 接下来系统BIOS将更新ESCD(Extended System Configuration Data，扩展系统配置数据)。ESCD是系统BIOS用来与操作系统交换硬件配置信息的一种手段，这些数据被存放在CMOS(一小块特殊的RAM，由主板上的电池来供电)之中。通常ESCD数据只在系统硬件配置发生改变后才会更新，所以不是每次启动机器时都能够看到“Update ESCD… Success”这样的信息。不过，某些主板的系统BIOS在保存ESCD数据时使用了与Windows 9x不相同的数据格式，于是Windows 9x在它自己的启动过程中会把ESCD数据修改成自己的格式。但在下一次启动机器时，即使硬件配置没有发生改变，系统BIOS也会把ESCD的数据格式改回来。如此循环，将会导致在每次启动机器时，系统BIOS都要更新一遍ESCD，这就是为什么有些机器在每次启动时都会显示出相关信息的原因。</p>

<p>j) ESCD更新完毕后，系统BIOS的启动代码将进行它的最后一项工作：即根据用户指定的启动顺序从软盘、硬盘或光驱启动MBR。在这个过程中会按照启动顺序顺序比较其放置MBR的位置的结尾两位是否为0xAA55，通过这种方式判断从哪个引导设备进行引导。在确定之后，将该引导设备的MBR内容读入到0x7C00[1]的位置，并再次判断其最后两位，当检测正确之后，进行阶段1的引导。</p>

<h4>EFI启动细节</h4>

<p>与传统MBR相比，GPT采用了不同的分区方式。</p>

<p>对于传统MBR，其结构主要如下：</p>

<p><img src="http://ytliu.info/images/2013-02-17-4.png" title="BIOS Graph" alt="BIOS Graph" /></p>

<p>上图即对上文中所述的很形象的说明，在图中看到MBR被分成三个部分，分别是：Bootloader、分别表以及Magic Number。其中Bootloader部分为stage1中被执行的起始部分。</p>

<p>相反，对于EFI系统中所采用的GPT分区方式，则采用了不同于MBR分区方式的形式，从下图中可以发现：</p>

<p><img src="http://ytliu.info/images/2013-02-17-5.png" title="EFI Graph" alt="EFI Graph" /></p>

<p>如上图所示，GPT分区表主要包括：保护MBR、首要GPT头、首要GPT、备用GPT、备用GPT头和磁盘数据区。保护MBR与正常的MBR区别不大，主要是分区表上的不同，在保护MBR中只要一个表示为0xEE的分区，以此来表示这块硬盘使用GPT分区表。首要GPT头包含了众多信息，具体内容如下：</p>

<p><img src="http://ytliu.info/images/2013-02-17-6.png" title="EFI Table" alt="EFI Table" /></p>

<p>分区表头定义了硬盘的可用空间以及组成分区表的项的大小和数量。分区表头还记录了这块硬盘的GUID，记录了分区表头本身的位置和大小（位置总是在LBA1）以及备份分区表头和分区表的位置和大小（在硬盘的最后）。它还存储着它本身和分区表的CRC32校验。固件、引导程序和操作系统在启动时可以根据这个校验值来判断分区表是否有错误，如果出错了，可以使用软件从硬盘最后的备份GPT分区表恢复整个分区表，如果备份GPT也校验错误，那么磁盘将不可用，系统拒绝启动。</p>

<p>接下来主要是128个分区表项，GPT分区表使用简单而直接的方式表示分区。一个分区表项的前16字节是分区类型GUID。例如，EFI系统分区的GUID类型是{C12A7328-F81F-11D2-BA4B-00A0C93EC93B} 。接下来的16字节是该分区的唯一的GUID（这个指的是该分区本身，而之前的GUID指的是该分区的类型）。在接下来是分区其实和末尾的64位LBA编号，以及分区的名字和属性。具体结构如下表：</p>

<p><img src="http://ytliu.info/images/2013-02-17-7.png" title="EFI Table2" alt="EFI Table2" /></p>

<h4>MBR引导</h4>

<p>接下来开始真正的引导过程了，主要说明GRUP的引导。总体上GRUB更像是一个mini os，只不过这个mini os的作用只是加载其他的操作系统，在GRUB中包括stage1、stage1.5（可选）和stage2，其中stage1和stage1.5属于boot loader，stage2属于mini os的内核部分。GRUB中stage1过程主要位于MBR的前446字节中（对于支持GPT分区的磁盘，同样有最开始的512字节作为保护MBR，保护MBR与正常的MBR区别不大，主要是分区表上的不同，在保护MBR中只要一个表示为0xEE的分区，以此来表示这块硬盘使用GPT分区表，不能识别GPT硬盘的操作系统通常会识别出一个未知类型的分区，并且拒绝对硬盘进行操作），之后的64字节为硬盘的分区表，最后两个字节为MBR结束标志位（0xAA55）。</p>

<p>stage1部分占用了446字节，其代码文件是源码目录下stage1/stage1.S文件，汇编后生成一个512字节的boot.img，被写在硬盘的0面0道1扇区中，作为硬盘的MBR。stage1的工作很简单，就是加载0面0道2扇区上的512字节到0×8000，然后跳转到0×8000执行。</p>

<p>在0面0道2扇区上的512字节内容为<code>stage1/start.S</code>文件汇编后生成。该扇区上的内容的作用是加载stage1.5或是stage2过程，并将控制权转交。</p>

<h4>Grub引导</h4>

<p>在start过程将控制权转交后，接下来就是GRUB的核心过程了。该过程之所以区分stage1.5和stage2，主要原因是GRUB和GRUB2的区别。在GRUB2中，将stage1.5过程集成到了stage2的过程中，所以stage1.5过程仅仅是针对GRUB的。下面将会分别介绍两种GRUB版本的两种过程。</p>

<p>4.1 GRUB中stage1.5过程</p>

<p>Stage1.5过程很无辜，它的作用很单一，但是非常关键。它的主要功用就是构造一个boot分区系统对应的文件系统，这样可以通过文件系统的路径（/boot/grub/）寻找stage2过程需要的core.img，进而加载到内存中开始执行。</p>

<p>Stage1.5存在于0面0道3扇区开始的地方，并一直延续十几k字节的区域，具体的大小与相应的文件系统的大小有关（文中涉及到了0面0道1-3+x扇区，这部分扇区为保留扇区，BIOS不会放置任何数据。正因为如此如果转换到GPT分区形式，系统将不能被正确引导，如上文所示，MBR后面的扇区都被其他内容所占据）。Stage1.5过程被构建成多种不同类型，但是功能类似，下面简单介绍一下基本的stage1.5过程的文件系统。e2fs_stage1_5（针对ext2fs，可引导ext2和ext3文件系统）、fat_stage1_5（针对fat文件系统，可引导fat32和fat16）、ffs_stage1_5、jfs_stage1_5、minix_stage1_5、reiserfs_stage1_5、vstafs_stage1_5和xfs_stage1_5，这些文件被称为stage1.5过程，这些文件每个至少都在11k以上。除此之外还有两个比较特殊的文件，分别为nbgrub和pxegrub，这两个文件主要是在网络引导时使用，只是格式不同而已，他们很类似与stage2，只是需要建立网络来获取配置文件。</p>

<p>由于stage1.5过程中会涉及到多个文件系统对应的文件，因此本文中主要以ext2fs为例进行说明，其他文件系统与此类似，可以同样进行分析理解。</p>

<p>对于ext2fs文件系统，用于生成该文件系统的stage1.5过程文件（e2fs_stage1_5）的代码为<code>stage2/fsys_ext2fs.c</code>文件。</p>

<p>在<code>stage2/filesys.h</code>文件中定义了每个文件系统对外的接口，用于上层调用，作为stage2过程寻找核心代码使用，文件系统一般被定义的接口主要就是三个函数，分别是mount、read和dir函数。对应ext2fs，其定义的函数为：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#ifdef FSYS_EXT2FS</span>
</span><span class='line'><span class="cp">#define FSYS_EXT2FS_NUM 1</span>
</span><span class='line'><span class="kt">int</span> <span class="n">ext2fs_mount</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="n">ext2fs_read</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="n">ext2fs_dir</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dirname</span><span class="p">);</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'><span class="cp">#define FSYS_EXT2FS_NUM 0</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>针对ext2fs有如上的函数名称，每个函数将具体在<code>stage2/fsys_ext2fs.c</code>文件中被定义，这里面没有包含任何的写的过程，对于bootloader而言仅仅读就可以完成任务了，没必要对其系统进行写操作。其中ext2fs_mount函数用于检查文件系统类型，并将superblock读入到内存中；ext2fs_read函数和ext2fs_dir函数用于对文件系统具体的操作。在<code>stage2/fsys_ext2fs.c</code>文件中除了需要对这三个函数的定义之外，还需要文件系统的属性的数据结构（superblock、inode和group结构，这些结构最初被定义在<code>include/linux/ext2_fs.h</code>文件中），通过这些数据结构描述一个文件系统。</p>

<p>如果读者有兴趣可以试着创建新的文件系统的支持，可以参照目前存在的一些文件系统的模板（实例）编写。</p>

<p>4.2 GRUB中stage2过程</p>

<p>GRUB中的核心过程也就是stage2过程了，该过程主要是在文件系统建立以后选择合适的操作系统进行加载并转交控制权，达到最后引导操作系统的目标。由于GRUB属于multi boot loader，因此在引导的时候要进行选择，选择哪种操作系统来运行。在GRUB内部主要包括两种方式，首先是从menu.list中读取显示到屏幕让用户选择，其次是通过grub-shell中定义的命令手动进行启动。本文将在后面介绍这两种方式如何运行，接下来先介绍一下stage2的具体的执行过程。</p>

<p>在上面一节中介绍过，stage1.5过程中将boot分区的文件系统加载了，之后又做了一件事情，就是将控制权转交给stage2，而stage2入口的地方就是<code>stage2/asm.S</code>文件。<code>Stage2/asm.S</code>文件属于汇编代码，主要作用是初始化C语言的运行环境，为下面执行C语言的函数做好准备，在准备好之后，将执行init_bios_info(<code>stage2/common.c</code>)函数。init_bios_info函数的作用是执行一些底层的函数，然后跳转到cmain执行，cmain函数位于<code>stage2/stage2.c</code>文件中。cmain函数内部进行一个死循环，在循环内部首先加载配置文件，显示给用户，在这同时循环一个内层循环，在内层循环中，获取配置文件中的命令，并解析执行。过程中如果没有可用的配置文件，那么进入命令行模式（enter_cmdline函数），如果找到可用的menu，那么开始执行menu的对应的内容（run_menu函数）。</p>

<p>对于enter_cmdline（<code>stage2/stage2.c</code>）函数，将调用find_command（<code>stage2/cmdline.c</code>），进而执行相应命令的函数。</p>

<p>对于run_menu（<code>stage2/stage2.c</code>）函数，将调用<code>stage2/cmdline.c</code>文件中的run_script函数，进而调用find_command，执行相应命令的函数。</p>

<p>这两种方式虽然经过了不同的过程，对用户输入的行为进行分析和处理，最终调用的函数为find_command，在该函数中顺序循环比较“输入”的命令是否与系统内部定义的相同，如果相同转到执行该函数。在这个比较的过程中包含了一个全局的数据结构为struct builtin（<code>stage2/shared.h</code>），由该数据结构组成了一个table类型（<code>stage2/builtins.c</code>），将命令与相对应的builtin结构对应一起并进行串联。下面描述一下builtin结构的定义：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">builtin</span> <span class="p">{</span>
</span><span class='line'>  <span class="cm">/* 命令名称，重要，是搜索命令时的依据*/</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span><span class='line'>  <span class="cm">/* 命令函数，重要，是搜索匹配后调用的函数*/</span>
</span><span class='line'>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span><span class='line'>  <span class="cm">/* 功能标示，一般未用到. */</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>  <span class="cm">/* 简短帮助信息*/</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">short_doc</span><span class="p">;</span>
</span><span class='line'>  <span class="cm">/* 完整帮助信息*/</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">long_doc</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">builtin</span> <span class="o">*</span><span class="n">builtin_table</span><span class="p">[]</span><span class="err">；</span>
</span></code></pre></td></tr></table></div></figure>


<p>有兴趣的读者可以对上面的内容进行扩展，形成自己的命令，主要在<code>stage2/builtins.c</code>文件中按照预定的格式更新，并添加到builtin_table中即可。</p>

<p>在上面打开配置文件的过程中，主要是通过一些文件操作函数（被定义在<code>stage2/disk_io.c</code>中）完成。这些文件操作函数主要包括：grub_open、grub_read、grub_seek和grub_close等，这些函数属于grub对外的上层接口，具体的函数内部将调用前文中提到的boot分区对应的文件系统的相应的函数完成，这个过程主要是通过回调函数来完成。该过程整体思路类似于面向对象过程，通过对象操作具体的函数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[乔帮主传有感]]></title>
    <link href="http://ytliu.github.com/blog/2013/01/12/qiao-bang-zhu-chuan-you-gan/"/>
    <updated>2013-01-12T20:34:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/01/12/qiao-bang-zhu-chuan-you-gan</id>
    <content type="html"><![CDATA[<p>这几周花了晚上的时间把乔帮主的传记给看完了。在我的记忆中我已经很久很久（或许久到甚至都不记得）没有看过什么名人传记，或许我本身就没有资格评论别人，而且由于自己的孤陋寡闻，也从来没有什么自己所谓的偶像。从乔帮主的传记中我惊叹于原来一个人可以那么真实地出现在这个世界中，通过他的创造力改变这个世界；居然存在一个让人看起来那么“讨厌”的人却有着别人无法逃脱的魅力；通过自己的意志让真正强大的人做到自己从未想过做到原本也确实无法做到的事，用他那强大到无法抗拒的“现实扭曲力场“来改变别人甚至使自己相信原本不存在的现实；他是一个自私到不行的非主流痞子，从不会设身处地地为周围的人考虑全凭自己一厢情愿去判定事物的好坏，去赞扬别人，去不惜代价地辱骂对方，但当面对全世界时，却毫不吝啬地为她着想，甚至去赌博这个世界未来的样子；或许没有一个人能像他那样将艺术和科技如此无缝地结合，让这个社会的普通人类去感受一个由它个人，以及一个伟大的公司所创造的更高的品味，即使是在即将离开人世的时候还在专注于此。他尽自己全力经营并留下的那个公司，由他物色、培养并使之无比强大的那些富有激情和创造力的人们，必将继续为我们大众带来一件件跨时代的产品，而他的一生一世，所经历的、所遭受的、所创造的、所改变的，留给世人一个神话般的存在，所有的这些遗产，不仅伟大，而且永恒。</p>

<!-- more -->


<p>当我看完上面这段文字，我都怀疑自己是否也进入的乔帮主的”现实扭曲力场“，被他的成就所折服，甚至忽略了他的一切令人厌恶的性格抑或缺点。在看书的过程中，他的太多做法使我无法理解，甚至强烈地抵抗，但却又有另一些让我毫无迹象地被其魅力和强大所折服，以至于甚至对他的偏激、阴暗面、对身边人的残酷、强大到无与伦比的控制欲、以及极其简单却让人无法理解的二元论，都带着一种幽默的嘲弄的态度，甚至会自发地将其归为其不可或缺的成功因子。当这种人出现，我又有什么资历，又怎么忍心去批判他，还带着无法忍受的态度去看待他呢？或许我的这些所想并非被逼迫，而是完全地心甘情愿吧？我敬重他、崇拜他、信任他、感激他，感动于他之所为，并发自内心地希望他一路走好。</p>

<p>尽管如此，虽然还仅仅是作为一个挣扎在毕业路上的IT学生，一方面，我无比愉悦而满怀感激地使用乔帮主为我们带来的ipad/iphone/air/icloud&#8230;，享受着它强烈的控制欲下设计且实现的近乎完美的端到端一体化系统和服务，一方面，我又在内心深处弱弱地支持着黑客精神，支持着用户对自己所拥有的一切（包括软件）的所有权和完全自由控制权。我毫无保留地信奉着开放对这个世界带来的绝对远胜于封闭，我信奉黑客世界中的自由而不作恶，我崇尚google文化，崇尚Linux等所有开源社区文化，崇尚git等这些为开源、开放所做出贡献的软件和组织。</p>

<p>我使用苹果的产品并热衷于此，但我却又无条件地支持开放与开源，而且我确信这样的人绝对不止我一个，而应该会是千千万万，那么这又是因为什么呢？</p>

<p>就在刚才我突然冒出来一个想法，或许是一个很显然和一目了然的想法，但是我发现我却刚刚才发现它，而且为此兴奋了好一阵子就如同我发现了一个真理一般。我想尝试着解答为什么，而且我相信这是唯一合理的解释。</p>

<h4>开放 &amp; 封闭</h4>

<p>我支持开放，因为我是一个开发者，是这个计算机世界中本应该创建规则的人，当这个世界中存在的规则开放了，才能更快地让这个世界不停滞地前进，试想如果每一个希望改进某个系统的人还需要重新再实现一个这个系统的话，每时每分每秒又能有多少所谓的创新呢？当这个世界的所有规则都是封闭的，又有多少人能进入这个世界而为此奉献自身呢？或许你可以说我们有点自私，希望用自己的方便换来单纯用户的更差体验，或许你可以说开放只是为了我们这些所谓的开发者更方便而简单地进行抄袭。发自内心地说，这些并不是没有道理，而且大量存在于现实社会中，但是这种现象不会长久，甚至会很容易由于其匮乏的核心竞争力迅速埋没，而创新的力量则会比原来任何时候都强大，况且封闭并不意味着没有抄袭，只是增加了难度而已，并非杜绝；而难道你又能否认封闭的windows没有从开放的linux里面借鉴些什么东西吗？开放使得我们创新于我们自己的东西，而不是纠结于已经存在于世的技术，而封闭只能将更多的人无情地拒之门外，或是浪费大量毫无价值的时间。</p>

<p>用户更喜欢苹果的产品（至少从目前的趋势来看），因为他们并不在意谁创造了苹果，并不在意这个世界的创新与前进出现在哪个公司，由那个hacker所推动。用户只在意于体验，在意于现在拿在我手中的产品是否满足于我的喜好，是否从品味上来看更优于其它。对于他们来说，封闭系统的创新总归可以由那些封闭系统的公司解决，因为不管是哪个封闭的系统总是由个人或公司开发的，只要最后结果符合需求，其它那些被封闭系统拒之门外或浪费大量时间的开发者又会有那个用户去care呢？苹果的优势在于他知道用户的心理，而由其强势控制的端到端一体化封闭系统是一个能够走在这条道路上的最可靠而又迅速的捷径。再加上苹果公司有着其它公司所缺乏的艺术与科技融合的本领以及其对未来电子产品的前瞻能力，于是他能在用户体验这个领域做出别人所无法比拟的成功，使得竞争对手甚至无法复制。而用户在乎的不就在于体验以及产品的品味吗？</p>

<p>而对于我来说，尽管我是一个开发者，我支持开放，但我同时也是一个不择不扣的用户，从一个普通用户的心态去评判产品时，苹果总能以它无以伦比的核心竞争力打败其它公司而被我选中。我没有Cory Doctorow那样”为什么我不会买ipad“这样的决心和霸气，因为一方面苹果的产品是无害的，而我也没有对我的手机具有完全控制能力的需求，而另一方面，苹果的电脑对于开发者的友好有时甚至优于linux等其它系统，只要我没有对这个系统本身做出修改或者控制的需求。</p>

<h4>我和计算机</h4>

<p>还记得在”我的梦想“这篇博文中我提到自己以后不想做和计算机相关的事，但是渐渐地，随着看的书越来越多，我发现我却慢慢喜欢上了IT这个行业，并不是因为我发现我的技术水平提高了，而是因为我发现计算机带给我，以及我们的，不仅仅是掌握了编程能力以至于挣口饭吃不至于饿死那么简单，它带给我的，是使得我能从一个更不同的视角来看待这个世界，而从这个角度中看到的世界，是一群人们所谓的书呆子，所谓的不谙世事的geek在用自己的方式改变世界、创造世界。是啊，我之前也说过我觉得自己没有创新的能力，没有那么的雄心壮志，但是渐渐地我发现，仅仅是默默地站在旁边，关注于这些时而微小时而不可思议的改变，仰望于这些可爱的geek们为这个我所生活的世界所带来的改变时，竟也如此的让我着迷。世界在无数个不同的领域进步着，被创造着价值，而真正的价值创造者们，不是那些或许站在公司最顶端的董事们、CEO等管理者们（更确切地说他们仅仅再为他们自己以及公司创造价值），也不是那些有着诡辩的口才每天产生收入的销售者们，而是这些真正地在创造着什么的工程师，或是人们所说的杰出的程序猿们！我没有渴望说我能创造出多大的价值，但是单单想着这些竟然也能让我兴奋，难道这个不是一种不一样的感觉吗？</p>

<p>我突然发现或许我该一直做下去，就算我像梦想中所说的从40岁开始开启一个新的生活，但是也不要放弃这项事业，或者更确切地说是这种生活，以一种程序员的角度来看待这个世界，感受它的变化，感受价值的创造和创造的过程，去亲手参与到这一系列从历史长河中必定会让人们不可思议的成就，哪怕只有一点点，哪怕连所谓的一点点都没有，或者我能为我自己创造出些什么东西，以及为我周围的人。</p>

<hr />

<p>真的很惊讶而又感动于乔帮主的一生，哪怕就是感受这么一个传奇的故事也能使得全身感到兴奋，或许这就是他的魅力吧，或者一个纯粹的创造者的利益吧，无与伦比，而又无可忘怀！没有人能知道乔布斯带给我了些什么或是改变了我什么，甚至你让我说，我也说不出，道不明吧。可是那又怎样呢，我确实感觉到了自己思想中的那么一些不一样，这就够了！</p>

<p>The Journey is the Reward, 过程就是奖励，后来想想我还是蛮喜欢这句话的，比那句”那些疯狂到以为自己能够改变世界的人，才能真正改变世界“更喜欢，或许是因为它更符合我的性格吧？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Base64编码]]></title>
    <link href="http://ytliu.github.com/blog/2013/01/06/base64bian-ma/"/>
    <updated>2013-01-06T12:42:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/01/06/base64bian-ma</id>
    <content type="html"><![CDATA[<p>这两天看<a href="http://www.csc.ncsu.edu/faculty/jiang/" title="Xuxian Jiang">Jiang</a>团队对<a href="http://www.csc.ncsu.edu/faculty/jiang/AnserverBot/" title="AnserverBot Malware">AnserverBot</a>的一篇详细的<a href="http://www.csc.ncsu.edu/faculty/jiang/pubs/AnserverBot_Analysis.pdf" title="AnserverBot Analysis">分析</a>中提到AnserverBot中对很多数据（比如C&amp;C server的url等）进行了Base64编码，于是，我对这种编码进行了了解，并根据他们实现的python解码脚本，写了一个ruby的解码脚本。</p>

<!-- more -->


<h4>Base64</h4>

<p>以下资料基本上来自于<a href="http://en.wikipedia.org/wiki/Base64" title="Base64">wiki</a></p>

<p>Base64用于对字符串进行编码，并将该编码通过网络传输出去，源于<code>MIME</code>内容（如邮件）的编码，用于防止内容在网络传输中被篡改。</p>

<p>接下来会通过一个示例进行说明：</p>

<p>首先我们会有一张Base64 index table:</p>

<p><img src="http://ytliu.info/images/2013-01-06-1.png" title="Base64 index table" alt="Base64 index table" /></p>

<p>该表记录了0-63（即000000-111111)对应的ASCII字符。</p>

<p>然后我们有一段需要翻译的字符串，一段从<a href="http://en.wikipedia.org/wiki/Thomas_Hobbes" title="Thomas Hobbes">Thomas Hobbes</a> <a href="http://en.wikipedia.org/wiki/Leviathan_book" title="Leviathan">Leviathan</a>的引用：</p>

<blockquote><p>Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.</p></blockquote>

<p>如果将每一个字母的ASCII码作为一个8-bit的二进制数展开的话会得到一个二进制串，比如我们<code>Man</code>的三个字母<code>M</code>、<code>a</code>、<code>n</code>的ASCII码分别为<code>77</code>、<code>97</code>、<code>110</code>，展开二进制并连起来既得到<code>010011010110000101101110</code>。然后我们将这个3x8的bit分成4x6，并将每6个bit组成的数字记下来，然后通过查询前面的那张<em>Base64 index table</em>即可得到四个字符<code>TWFu</code>，也就是<code>Man</code>的Base64表达形式。如下图所示：</p>

<p><img src="http://ytliu.info/images/2013-01-06-2.png" title="Base64 example" alt="Base64 example" /></p>

<p>当然这张<em>Base64 index table</em>可以采用任意的字母数字顺序，而不用按照这种顺序，只要解码的时候用同一张index table就可以了。</p>

<p>还有一点要注意的是如果字符的数目不是3的倍数该怎么办？也就是说最后一个block也有可能是1个字符或者2个字符。这个时候就需要在后面再加0来进行补齐了，然后再用Base64的规则进行转换，在编码后的base64文本后加上一个或两个<code>=</code>号，代表补足的字节数。也就是说，当最后剩余1个字符时，最后一个6位的base64字节块有四位是0值，最后附加上两个等号；如果最后剩余2个字符时，最后一个6位的base64字节块有两位是0值，最后附加一个等号。</p>

<h4>Base64 decode by Ruby</h4>

<p>在ruby中可以通过<code>requite 'base64'</code>来很方便地对Base64字符串进行解码，比如在AnserverBot中，采用了<code>STvJjktoVFZ9f0PGlicqy3xK7zH8ruXdn5WwDRIeb1UmEgOhYs2NpLC4QBa6AM+/_</code>的<em>index table</em>进行编码，于是ruby程序如下所示：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># decrypt str encoded by base64</span>
</span><span class='line'><span class="c1"># ARGV[0] translate command (0 for string, 1 for file)</span>
</span><span class='line'><span class="c1"># ARGV[1] translate string or file</span>
</span><span class='line'><span class="c1"># ARGV[2] my_base64chars if exist</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nb">require</span> <span class="s1">&#39;base64&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="k">BEGIN</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">&quot;Hello!</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">cmd</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">to_i</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="no">ARGV</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;Usage: ruby </span><span class="si">#{</span><span class="vg">$0</span><span class="si">}</span><span class="s2"> [0|1] [str|file] [base64chars]&quot;</span>
</span><span class='line'>  <span class="nb">exit</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">cmd</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'><span class="k">elsif</span> <span class="n">cmd</span> <span class="o">==</span> <span class="mi">1</span>
</span><span class='line'>  <span class="n">f</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">translate string is:</span><span class="se">\n</span><span class="si">#{</span><span class="n">s</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std_base64chars</span> <span class="o">=</span> <span class="s2">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="no">ARGV</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">!=</span> <span class="kp">nil</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="no">ARGV</span><span class="o">[</span><span class="mi">2</span><span class="o">].</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">65</span><span class="p">)</span>
</span><span class='line'>  <span class="n">my_base64chars</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="n">my_base64chars</span>  <span class="o">=</span> <span class="s2">&quot;STvJjktoVFZ9f0PGlicqy3xK7zH8ruXdn5WwDRIeb1UmEgOhYs2NpLC4QBa6AM+/_&quot;</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">translate str according to </span><span class="si">#{</span><span class="n">my_base64chars</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">tr</span><span class="p">(</span><span class="n">my_base64chars</span><span class="p">,</span> <span class="n">std_base64chars</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">data</span> <span class="o">=</span> <span class="no">Base64</span><span class="o">.</span><span class="n">decode64</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">translated str is </span><span class="si">#{</span><span class="n">data</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">END</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Bye!&quot;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中<code>s.tr(my_base64chars, std_base64chars)</code>是将自定义的<em>index table</em>和标准<em>index table</em>进行下转换，将字符串中的字符用标准<em>index table</em>中对应的字符进行替换，然后再通过<code>Base64.decode64(s)</code>进行解码。</p>

<p>整个过程还是很简单的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Qemu study for Android emulator]]></title>
    <link href="http://ytliu.github.com/blog/2012/12/30/qemu-study-for-android-emulator/"/>
    <updated>2012-12-30T19:10:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/12/30/qemu-study-for-android-emulator</id>
    <content type="html"><![CDATA[<p>这两天看了下android emulator的源代码，位置在<code>android-src/external/qemu</code>里面，</p>

<p>编译和启动的方式很简单；</p>

<pre><code>$ ./android-configure.sh
$ make
$ export ANDROID_SDK_ROOT=/path/to/androdi-sdk
$ emulator-arm @4.2
</code></pre>

<p>你可以对源码进行修改，然后重新编译、使用，而这里主要要讲的是qemu的运行原理，资料来源是<a href="http://lists.gnu.org/archive/html/qemu-devel/2011-04/pdfhC5rVdz7U8.pdf">Qemu detailed study</a>。要说明的一点是，android emulator原理基本上是和qemu一样的，只是加了一些android specific的东西在里面。</p>

<!-- more -->


<p>首先是qemu整体流程：</p>

<p><img src="http://ytliu.info/images/2012-12-30-1.png" title="qemu process" alt="qemu process" /></p>

<p>首先将guest code（这里即为arm code）被TCG（Tiny Code Generator)转换成一个中间表达，然后再转换成host code（这里即为x86 code），具体来说分为两步：</p>

<ul>
<li>一个TB（Translation Block）被翻译成TCG ops</li>
<li>TCG ops被翻译成host code</li>
</ul>


<p>我们先来看下qemu的code base：</p>

<p><img src="http://ytliu.info/images/2012-12-30-2.png" title="qemu code base" alt="qemu code base" /></p>

<ul>
<li><code>vl.c/vl-android.c</code>: 这个是整个qemu的入口函数，主要是初始化qemu环境，然后进入<code>main_loop</code>；</li>
<li><code>target-xyz/translate.c</code>: 将guest code翻译成TCG ops；</li>
<li><code>tcg/*/tcg-target.c</code>: 将TCG ops翻译成host code；</li>
<li><code>tcg/tcg.c</code>: TCG的主函数；</li>
<li><code>cpu-exec.c</code>: 寻找下一个TB（如果没找到则调用tcg.c生成TB），然后执行。</li>
</ul>


<p>在qemu中也很好地利用了locality，即没产生一段code（TCG ops或host code），就将其存在一个code cache中，然后用LRU进行替换。</p>

<h4>运行流程（code perspective）</h4>

<p>主要分为两部分： <em>代码生成</em>和<em>代码运行</em></p>

<h5>代码生成</h5>

<p>这是主要部分，流程是这样的：</p>

<p><img src="http://ytliu.info/images/2012-12-30-3.png" title="qemu process from code perspective" alt="qemu process from code perspective" /></p>

<p>其中函数<code>cpu_exec()</code>相当于主要的执行循环函数，它将TB第一次初始化，在两个嵌套无限for循环中通过<code>tb_find_fast()</code>来获得host code TB，然后通过<code>tcg_qemu_tb_exec()</code>来执行相应代码。</p>

<p><code>tb_find_fast</code>会首先查看code cache中是否有TB存在了，有则直接执行<code>tcg_qemu_tb_exec()</code>，否则通过<code>tb_find_slow()</code>来查找或者生成TB，后者通过一系列调用，最后到达<code>disas_insn()</code>，该函数执行了实际的guest code到TCG ops的翻译，并将其加入TCG ops的code buffer，最后调用<code>tcg_gen_code()</code>来生成host code。</p>

<h5>代码运行</h5>

<p>代码运行就是通过<code>tcg_qem_tb_exec()</code>来实现的，可以看到，其实这是一个宏，定义在<code>tcg/tcg.h</code>里面：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define tcg_qemu_tb_exec(tb_ptr) \</span>
</span><span class='line'><span class="cp"> ((long REGPARM __attribute__ ((longcall)) (*)(void *))code_gen_prologue)(tb_ptr)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个感觉非常复杂的调用，我们知道， <code>((long REGPARM (*)(void *))</code> 是一个指向函数的指针，<code>void *</code>是它的参数，返回值为<code>long</code>；而在这里 <code>REGPARAM(*)</code>是一个GCC选项，表示函数是通过寄存器传参而不是通过栈传参的。</p>

<p>而一个数组的名字表示的是指向这个数组的基地址，于是，<code>(function_pointer) array_name</code>则会将这个基地址cast成一个函数地址。</p>

<p>另外，一个函数可以通过<code>(*pointer_to_func)(args)</code>被调用，所以<code>((long REGPARM (*)(void *))code_gen_prologue)(tc_ptr)</code>进行了一次函数调用，似乎在这里少了一个<code>*</code>号，不过其实只要测试下可以发现 <code>(*pointer_to_func)(args)</code>和<code>(pointer_to_func)(args)</code>是一样的。</p>

<p>所以上面<code>tcg_qemu_tb_exec(tb_ptr)</code>翻译的宏可以表示为一个数组<code>code_gen_prologue</code>被cast成一个函数指针，参数为<code>tc_ptr</code>，返回值为<code>long</code>（指向下一个TB），并且被调用。其实，被<code>code_gen_prologue</code>指向的函数就是<code>Function Prologue</code>，将控制流转到<code>tc_ptr</code>指向的host code开头部分。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如果明天是世界末日]]></title>
    <link href="http://ytliu.github.com/blog/2012/12/20/ru-guo-ming-tian-shi-shi-jie-mo-ri/"/>
    <updated>2012-12-20T21:44:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/12/20/ru-guo-ming-tian-shi-shi-jie-mo-ri</id>
    <content type="html"><![CDATA[<p>那我觉得今天过的好没意义啊。</p>

<p>早晨起床，刷牙，洗脸，拉尿，换衣服，滑轮滑去买了两个肉包，到实验室喝了杯蜂蜜水，写了两行related work，被叫去开组会，突然华为的人进来又听海波和他们讨论了一个上午，中午吃了碗和方便面长的一样但是比方便面难吃还要17块钱的“辛拉面”，回到实验室抄了两个小时的政治课笔记，莫名其妙地又待了一个小时写了几行related work，唯一还算比较有意义的就是晚上和实验室去吃了世界末日前最后一餐，回来被小呆众闺蜜调戏了一番，然后和“追梦的贱人们”聊了会儿天&#8230;然后等下又要冒着雨会寝室，洗脸洗脚，刷牙睡觉&#8230;</p>

<p>如果明天真的是世界末日的话，那这个就算我的遗嘱了吧&#8230;</p>

<!-- more -->


<p>算了，虽然懒，但是还是再加几句吧：</p>

<blockquote><p>很高兴认识你们（你们懂的），如果还有下辈子（我还是比较相信投胎一说的），我还是希望在另外一个星球遇到你们，然后和你们一起傻一起疯，一起度过最二逼的青春岁月。<br/>然后，我还要在初中遇到小呆，经过一段暧昧的光年，传递那么几封可以用来回忆当年青涩傻逼岁月的信，然后再来上那个霸气的短信“刘宇涛先生，要不我们不谈了，直接结婚吧”，再然后，度过一段充满思念的异地恋，最终在一起，每周都能见个面，开启个“相亲相爱”模式，或者偶尔听你哭一哭，安静地看着你流泪，然后来个强有力的男人的拥抱&#8230;<br/>至于读书嘛~就不读那么认真啦，多享受享受生活，把自己想做的事不管有钱没钱有时间没时间都一股脑儿挤出时间来做掉，省的又来个世界末日啥的。<br/>世界太危险，读博要谨慎啊&#8230;</p></blockquote>


<p>好了，就这些吧，让暴风雨来的更猛烈些，把这一切都冲毁吧，包括我以上那些无聊的YY&#8230;</p>

<p>还是回去早点洗洗睡了吧》》》</p>

<blockquote><p>就算世界没了，那又关我鸟事呢啦啦啦》》》</p></blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic Linker]]></title>
    <link href="http://ytliu.github.com/blog/2012/12/15/dynamic-linker/"/>
    <updated>2012-12-15T13:03:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/12/15/dynamic-linker</id>
    <content type="html"><![CDATA[<p>在了解dynamic linker之前，得先对ELF文件有一个初步的了解：</p>

<p>在<a href="http://www.jollen.org/blog/2006/12/enabling_dynamic_loader_1.html" title="elf">jollen</a>的博客中有一断对ELF Session的表格:</p>

<p><img src="http://ytliu.info/images/2012-12-09-1.png" title="elf section" alt="elf section" /></p>

<p>很有参考价值。其中将会涉及到的sections有<em>.got</em>, <em>.plt</em>, <em>.interp</em>。</p>

<p>另外在<a href="http://www.bottomupcs.com/" title="computer science from bottom up">Computer Science from the Bottom Up</a>中有一章对dynamic linker进行了详细的说明。</p>

<p>以下的内容很多来自于该文档和俞甲子的《程序员的自我修养》一书第七章。</p>

<!-- more -->


<p>问题的产生是这样子的：当我们使用一段shared library的时候，它并没有指定说一定要把相应的代码放在哪个内存地址，而是由dynamic linker根据当前内存情况选择一段最合适的内存区域用于放置相应的code和data。那么dynamic linker是怎么做的呢？我们举一个很简单的例子来说明；</p>

<p>首先，我们编写并编译一段动态链接库lib.c, lib.h：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &quot;lib.h&quot;;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;in dynamic lib, i is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">Char</span> <span class="o">*</span><span class="n">dylib</span> <span class="o">=</span> <span class="s">&quot;Test Dynamic Linker String&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">test</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后将其编译为动态连接库libtest.so</p>

<pre><code>$ gcc -fPIC -shared -o libtest.so lib.c
</code></pre>

<p>这里 &#8220;-shared&#8221;表示产生共享对象，&#8221;-fPIC&#8221;表示地址无关代码，这在后面会说。</p>

<p>然后我们编写一段程序dytest.c来利用libtest.so:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &quot;lib.h&quot;;</span>
</span><span class='line'>
</span><span class='line'><span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dylib</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dylib</span><span class="p">);</span>
</span><span class='line'>    <span class="n">test</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后对其进行编译：</p>

<pre><code>$ gcc -o dytest dytest.c ./libtest.so
$ ./dytest
Hello, Test Dynamic Linker String
in dynamic lib, i is 5
</code></pre>

<p>就这么一段简单的测试代码中，动态链接是怎么完成的呢？它和静态链接有什么不同呢？</p>

<p>在静态链接中，整个程序只有一个可执行文件，在这个可执行文件中，所有变量和函数的地址都已经固定好了（这是由linker在链接时从静态链接的文件中读出来并进行地址重定位），而在动态链接中，这些地址并不会进行地址重定位。那么，链接器怎么知道一个地址是静态符号还是动态符号呢？其实在我们编译dytest的时候也将libtest.so加进去进行编译了，而在libtest.so中保存了完整的符号信息，从而linker可以知道该符号是一个动态符号。</p>

<p>既然动态链接库主要用于共享，那么有一个问题：共享对象在编译时不应该假设自己在进程虚拟地址空间中的位置。一种解决的方法是采用“装载时重定位”，但是这样有一个缺点，因为它要在程序装载时对指令部分进行修改，所以就无法使得指令部分在多个进程中共享，这样就失去了共享库的优势，另一种就是地址无关代码，它的基本想法就是把指令中那些需要修改的部分分离出来，和数据放在一起。</p>

<p>我们把地址引用分为4个部分</p>

<ul>
<li>模块内部函数调用</li>
<li>模块内部数据访问</li>
<li>模块外部数据访问</li>
<li>模块外部函数调用</li>
</ul>


<p>第一种情况应该是最简单的，因为在模块内部函数与调用者的位置是相对的，可以采取相对地址调用。</p>

<p>第二种情况同样采用相对地址的访问，这里有一个trick，就是如何得到数据地址和当前地址的相对值，俞子甲的书中介绍了一种方法(7.3节)。另外，在处理共享库的全局变量的时候，编译器都把它当作定义在其它模块的全局变量，相当于后面讲的类型三，使用GOT表。</p>

<p>第三种情况就复杂一点了，因为它要等到装载时才能决定。这里就要用到GOT（Global Offset Table）表了，ELF在数据段中建立一个指向相关地址的指针数组。对于数据变量a，在GOT表中有一个4bytes的地址项与之对应，在程序装载时，链接器会找到这个变量的地址，并将该项进行修改。</p>

<p>第四种情况和第三种类似，只是地址为函数地址。</p>

<p>其实还有第五中情况，就是模块间的全局变量，比如下面这个例子：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">extern</span> <span class="kt">int</span> <span class="n">global</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">global</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果一个定义在共享模块内部的全局变量，编译器并不知道它是否会被其它模块使用，所以当前编译器在遇到这种全局变量的时候都会把其当做定义在其它模块中的全局变量，即上面的第三种情况，使用GOT表进行访问。</p>

<p>这里还要注意一点的是，在产生地址无关代码的时候参数-fpic和-fPIC的区别，-fpic产生的代码相对较小，而且较快，但是对于一些硬件平台有一些限制。另外，它也可以被用在可执行代码上，这时，就被称为PIE（using -fPIE or -fpie）。</p>

<p>这里需要澄清的一点是，对于一个共享库lib.so来说，它在不同的进程中都有自己独立的副本，而在同个进程不同线程中则是共享的。而对于多进程共享全局变量使用的是“共享数据段”，而多线程访问不同全局变量则被称为“线程私有存储”。</p>

<p>还有，对于数据段的绝对地址引用，可以用到装载时重定位的方法来解决，即对于共享对象来说，如果数据段中有绝对地址引用，如static int *p = &amp;a，编译器和链接器会产生一个重定位表，当动态链接器装载共享对象时若发现有重定位入口，则对其进行重定位。</p>

<h4>延迟绑定（PLT）</h4>

<p>在动态链接的程序开始运行的时候都会通过动态链接器寻找并装载共享对象，但是有些函数其实可能并不会被调用。为了增加性能，会采用一种被称为PLT（Procedure Linkage Table）的方式，它的基本思想就是当函数第一次被用到时才进行绑定。它采用了一些很精巧的指令来完成:</p>

<p>每个外部函数都有一个在PLT对应的项（bar@plt)</p>

<pre><code>bar@plt:
jmp *(bar@GOT)
push n
push moduleID
jmp _dl_runtime_resolve
</code></pre>

<p>在这里第一条指令跳转到bar在GOT中的项，该项中的初始地址即为这里第二条指令（push n）的地址，相当于没有效果，然后将bar的信息和其所在模块的信息压入栈，最后调用_dl_runtim_resolve将bar真正对的地址填入到bar@GOT中，当下次真正调用bar的时候就会跳转到真正的函数地址，并返回到调用者，而不会回到<em>push n</em>的地址了。</p>

<p>ELF将GOT分成了两个表“.got&#8221;和&#8221;.got.plt&#8221;, &#8220;.got&#8221;用来保存全局变量引用地址，&#8221;.got.plt&#8221;用来保存函数引用的地址，在&#8221;.got.plt&#8221;中前三项是有特殊意义的：</p>

<ul>
<li>第一项保存&#8221;.dynamic&#8221;段的地址，这个段描述了本模块动态链接相关的信息；</li>
<li>第二项保存的是本模块的ID；</li>
<li>第三项保存的是_dl_runtime_resolve()的地址。</li>
</ul>


<p>而&#8221;.got.plt&#8221;的其余项分别对应每个外部函数的引用。</p>

<h4>动态链接相关结构</h4>

<p>在动态链接的情况下，在装载完可执行文件之后，操作系统会将控制权转交给动态链接器，动态链接器的路径在&#8221;.interp&#8221;下指定。</p>

<p>和动态链接相关的段比如说：</p>

<h5>.dynamic</h5>

<p>动态链接器中最重要的结构就是&#8221;.dynamic&#8221;段，它就像动态链接下ELF文件的”文件头“。</p>

<h5>.dynsym</h5>

<p>&#8220;.dynsym&#8221;段是为了表示模块间动态链接相关符号的导入导出关系的，当然，和&#8221;.symtab&#8221;段类似，它也需要一些辅助的表，如&#8221;.dynstr&#8221;动态符号字符串表，&#8221;.hash&#8221;符号哈希表。</p>

<h5>动态链接重定位表</h5>

<p>&#8220;rel.dyn&#8221;和&#8221;rel.plt&#8221;相当于静态链接中的&#8221;rel.data&#8221;和&#8221;rel.text&#8221;。&#8221;rel.dyn&#8221;是对数据引用的修正，它所修正的位置即&#8221;.got&#8221;以及数据段，而&#8221;.rel.plt&#8221;则是对函数引用的修正，即&#8221;.got.plt&#8221;段。</p>

<h4>动态链接的步骤和实现</h4>

<p>主要分为三步：</p>

<h5>动态链接器自举</h5>

<p>这里有两个条件：</p>

<ul>
<li>本身不可以依赖于其它任何共享对象</li>
<li>本身所需要的全局和静态变量的重定位工作由其本身完成——即“自举”</li>
</ul>


<h5>装载共享变量</h5>

<p>从全局符号表中开始寻找其所依赖的共享变量，即&#8221;.dynamic&#8221;段中一个DT_NEEDED类型，将里面提到的所有共享对象的名字放入一个装载集合中，然后从集合中一个个读取共享变量名字，找到相对应的文件，读取里面的ELF文件头和&#8221;.dynamic&#8221;段，然后将相应的代码段和数据段映射到其地址空间中，并递归地做这件事。所以当所有共享变量都被装载进来后，全局符号表里面将包含所有动态链接所需要的符号。</p>

<h4>重定向和初始化</h4>

<p>装载完成后，链接器开始重新遍历可执行文件和每个共享对象的重定向表，将其GOT/PLT中需要重定向的进行修正，然后就将控制权转交给程序的入口了。由此，动态链接也就完成了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ASLR in android]]></title>
    <link href="http://ytliu.github.com/blog/2012/12/09/aslr-in-android/"/>
    <updated>2012-12-09T11:07:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/12/09/aslr-in-android</id>
    <content type="html"><![CDATA[<p>这两篇看了两篇文章分析<a href="https://blog.duosecurity.com/2012/02/a-look-at-aslr-in-android-ice-cream-sandwich-4-0/" title="asli in 4.0">aslr in androi4.0</a>和<a href="https://blog.duosecurity.com/2012/07/exploit-mitigations-in-android-jelly-bean-4-1/" title="aslr in 4.1">android 4.1</a>，觉得蛮有趣的，这里简单介绍下。</p>

<h3>ASLR with Liux Kernel</h3>

<p>首先介绍下linux中的ASLR，ASLR可以对任意内存进行随机化：</p>

<!-- more -->


<ul>
<li>stack：The userspace stack mapping set up by the kernel during exec(2) should be sufficiently randomized. Stack randomization is performed by the randomize_stack_top() function.</li>
<li>Heap：The heap location returned by the brk(2) system call when a program is first exec’ed should be randomized. Heap randomization is performed by the arch_randomize_brk() function.</li>
<li>Libs and mmap：After NX was introduced, static library mapping led to the popularity of ret-to-libc and more generic ret-to-lib attacks. The location of libraries and other mmap’ed regions should be randomized.</li>
<li>Exec：Even if you’re randomized the mapping of all the shared libaries that an executable uses, you still need to randomize the location of the executable itself when it is mapped into the address space. Otherwise, the executable mapping can be used as a source for ROP gadgets.</li>
<li>Linker：On most Linux systems, the ld.so dynamic linker provided by glibc can self-relocate itself, so its mapping is randomized. However, as we’ll see, this isn’t the case for all linkers.</li>
<li>VDSO(Virtual Dynamically-linked Shared Object)：an executable mapping of a virtual shared library provided by the kernel for syscall transitions. However, most Android devices run on the ARM architecture, which doesn’t use a VDSO.</li>
</ul>


<h3>ASLR in Android 2.x</h3>

<p>在Android 2.x开始，唯一对ASLR支持的是stack（这可以通过多次查看/proc/pid/maps来发现），其通过load_elf_binary()函数调用randomize_stack_top()来实现：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#ifndef STACK\_RND\_MASK</span>
</span><span class='line'><span class="cp">#define STACK\_RND\_MASK (0x7ff &gt;&gt; (PAGE\_SHIFT - 12)) </span><span class="cm">/* 8MB of VA */</span><span class="cp"></span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">randomize</span><span class="err">\</span><span class="n">_stack</span><span class="err">\</span><span class="n">_top</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack</span><span class="err">\</span><span class="n">_top</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">random_variable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">((</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_RANDOMIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>              <span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">personality</span> <span class="o">&amp;</span> <span class="n">ADDR_NO_RANDOMIZE</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">random_variable</span> <span class="o">=</span> <span class="n">get_random_int</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">STACK_RND_MASK</span><span class="p">;</span>
</span><span class='line'>            <span class="n">random_variable</span> <span class="o">&lt;&lt;=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'><span class="cp">#ifdef CONFIG\_STACK\_GROWSUP</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">stack</span><span class="err">\</span><span class="n">_top</span><span class="p">)</span> <span class="o">+</span> <span class="n">random_variable</span><span class="p">;</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">stack</span><span class="err">\</span><span class="n">_top</span><span class="p">)</span> <span class="o">-</span> <span class="n">random_variable</span><span class="p">;</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>ASLR in Android 4.0</h3>

<p>而在4.0，即其所谓的支持ASLR的版本上，其实ASLR也仅仅增加了对libc等一些shared libraries进行了随机化，而对于heap, executable和linker还是static的。</p>

<p>对于heap的随机化来说，可以通过</p>

<pre><code>echo 2 &gt; /proc/sys/kernel/randomize_va_space
</code></pre>

<p>来开启。</p>

<p>而对于executable的随机化，由于大部分的binary没有加GCC的-pie -fPIE选项，所以编译出来的是EXEC，而不是DYN这种shared object file，因此不是PIE（Position Independent Executable），所以没有办法随机化；</p>

<p>同样的linker也没有做到ASLR。</p>

<h3>ASLR in Android 4.1</h3>

<p>终于，在4.1 Jelly Bean中，Android终于支持了所有内存的ASLR。在第二个对4.1ASLR介绍中，作者列出了从Android 1.5开始用到的安全加强机制：</p>

<h5>Android 1.5+</h5>

<ul>
<li>ProPolice to prevent stack buffer overruns (-fstack-protector)</li>
<li>safe_iop to reduce integer overflows</li>
<li>Extensions to OpenBSD dlmalloc to prevent double free() vulnerabilities and to prevent chunk consolidation attacks. Chunk consolidation attacks are a common way to exploit heap corruption.</li>
<li>OpenBSD calloc to prevent integer overflows during memory allocation</li>
</ul>


<h5>Android 2.3+</h5>

<ul>
<li>Format string vulnerability protections (-Wformat-security -Werror=format-security)</li>
<li>Hardware-based No eXecute (NX) to prevent code execution on the stack and heap</li>
<li>Linux mmap_min_addr to mitigate null pointer dereference privilege escalation (further enhanced in Android 4.1)</li>
</ul>


<h5>Android 4.0+</h5>

<ul>
<li>Address Space Layout Randomization (ASLR) to randomize key locations in memory</li>
</ul>


<h5>Android 4.1+</h5>

<ul>
<li>PIE (Position Independent Executable) support</li>
<li>Read-only relocations / immediate binding (-Wl,-z,relro -Wl,-z,now)</li>
<li>dmesg_restrict enabled (avoid leaking kernel addresses)</li>
<li>kptr_restrict enabled (avoid leaking kernel addresses)</li>
</ul>


<p>在Android 4.1中，基本上所有binary都被编译和连接成了PIE模式（可以通过readelf查看其Type）。所以，相比于4.0，4.1对Heap，executable和linker都提供了ASLR的支持。</p>

<p>另外，4.1还增加了几个小的安全加强机制：</p>

<ul>
<li>大部分系统binary都添加了RELRO和BIND_NOW的编译flag，起作用主要是将GOT表设置成只读，防止之前出现过的<a href="http://jon.oberheide.org/files/bsides11-dontrootrobots.pdf" title="don't root robot">Gingerbreak</a>攻击。</li>
<li>另外，对dmesg_restrict / kptr_restrict的sysctl的利用，有效防止了一些低权限的用户从dmesg/klogctl中读取一些敏感信息，或者读取一些kernel内存中的敏感数据（比如很多/proc下的接口）。</li>
</ul>


<h3>What&#8217;s next</h3>

<p>之后作者还提到一些还需要继续努力的事：</p>

<ul>
<li>ASLR的弱点 - 32-bit，容易破解</li>
<li>一些安全的libc调用，比如FORTIFY_SOURCE</li>
<li>PaX Hardening，虽然很多不适合手机，但是也可以cherry pick一些啦</li>
<li>MAC/RBAC，其实这个现在也已经有了，比如SEAndroid&#8230;</li>
<li>Mandatory Code Signing，向IPhone学习吧</li>
</ul>


<p>另外，作者还提到一个Zygote的问题，为了性能问题，现在Android上所有的进程都是Zygote fork出来的，也就是说很多的地址空间在fork出来后是固定不变的，这样也就出现了一种可能性：a malicious app on a victim’s device leaks address mappings from its own process off to an attacker to assist in exploiting another process (eg. the browser) that might have higher privilege or valuable data.</p>

<p>当然，作者认为这种场景可能性比较小，所以还不算一个大问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[get root in my android]]></title>
    <link href="http://ytliu.github.com/blog/2012/12/08/get-root-in-my-android/"/>
    <updated>2012-12-08T16:28:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/12/08/get-root-in-my-android</id>
    <content type="html"><![CDATA[<p>首先申明，这其实并不是一篇android root教程，因为我并没有用什么exploit的方法，也没有用CWM等这些第三方ROM，而是改了ASOP，然后把它刷到机子上，然后对其进行所谓的root，装了一个dSploit和busybox。</p>

<p>具体的做法是这样的：</p>

<ul>
<li>更新到ASOP的最新版 - 4.2.4</li>
<li>lunch full-maguro, make</li>
<li>fastboot to smartphone</li>
<li>把手机连到电脑上，通过adb shell上去，进入su模式</li>
<li>通过<a href="http://www.cypherpunk.at/2011/10/08/manual-rooting-android-on-linux-2/" title="manual rooting">这里</a>的方法进行root</li>
</ul>


<!-- more -->


<p>即：</p>

<ul>
<li>mount -o remount,rw /dev/block/&#8230;/system /system</li>
<li>mv path/to/modified/su /system/xbin/su</li>
<li>mount -o remount,ro /dev/block/&#8230;/system /system</li>
</ul>


<p>但是发现失败了，我怀疑是su这个文件不兼容，于是，我想了一个更贱的方法：</p>

<ul>
<li>把ASOP代码中的/system/extras/su/su.c该掉，把检查的部分全部去掉</li>
</ul>


<p>在这里，我把</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">myuid</span> <span class="o">!=</span> <span class="n">AID_ROOT</span> <span class="o">&amp;&amp;</span> <span class="n">myuid</span> <span class="o">!=</span> <span class="n">AID_SHELL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">&quot;su: uid %d not allowed to su</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">myuid</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注释掉，另外，把</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">setgid</span><span class="p">(</span><span class="n">gid</span><span class="p">)</span> <span class="o">||</span> <span class="n">setuid</span><span class="p">(</span><span class="n">uid</span><span class="p">))</span> <span class="p">{</span>
</span></code></pre></td></tr></table></div></figure>


<p>换成了</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">setgid</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="n">setuid</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>然后刷机</li>
</ul>


<p>这样就直接root了！不过这只能用于我的测试机啦，正常的手机千万不敢那么做，太危险了！</p>

<hr />

<p>另外，我用了两款软件，<a href="https://github.com/evilsocket/dsploit" title="dsploit">dSploit</a>和<a href="github.com/mwrlabs/mercury" title="mercury">Mercury</a>，而且都有源码，准备之后两周研究下，学习下android编程和如何进行penetration</p>
]]></content>
  </entry>
  
</feed>
