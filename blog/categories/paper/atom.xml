<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Paper | Mctrain's Blog]]></title>
  <link href="http://ytliu.github.com/blog/categories/paper/atom.xml" rel="self"/>
  <link href="http://ytliu.github.com/"/>
  <updated>2013-05-27T11:19:40+08:00</updated>
  <id>http://ytliu.github.com/</id>
  <author>
    <name><![CDATA[Liu Yutao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[浅谈某些攻击及其防范]]></title>
    <link href="http://ytliu.github.com/blog/2012/02/25/qian-tan-mou-xie-gong-ji-ji-qi-fang-fan/"/>
    <updated>2012-02-25T21:03:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/02/25/qian-tan-mou-xie-gong-ji-ji-qi-fang-fan</id>
    <content type="html"><![CDATA[<p>很多时候我觉得攻击和防范的历史就像一部电视连续剧，不断出现的魔高一尺道高一丈，此消彼长，生生不息……</p>

<p>这篇博文的初衷来源于6.858中lecture2里面最后的一篇references:</p>

<pre><code>    INTERPRETER EXPLOITATION: POINTER INFERENCE AND JIT SPRAYING
</code></pre>

<p>这是一篇介绍两个技术<em>pointer inference</em>和<em>JIT spraying</em>的文章，关于这篇文章我应该会在之后详细介绍，这里想说的又是里面引出的一篇报告：</p>

<p><a href="http://www.azimuthsecurity.com/resources/bh2008_dowd_sotirov.pdf" title="bypassing">Bypassing Browser Memory Protections</a></p>

<p>里面介绍了微软在软硬件层面对5种攻击所作的防范，以及攻击者可以如何绕开这些防范。这里的描述方式也按文中一样按照防范措施来分类感觉会比较清晰点吧</p>

<h4><strong>前言</strong></h4>

<p>对于一个成功的攻击，有很大一部分是需要用到<em>buffer overflow</em>技术的，而<em>bf</em>分为很多，主要看你要覆盖什么内容，之后如何使得控制流变成你想要执行的代码，对于之后的这些攻击技术，也就出现了相应的防范策略和机制。但不管怎么说，这里所提到的所有攻击都源自于<em>bf</em>，没有它的攻击属于另外的范畴，这篇暂且不谈。</p>

<!-- more -->


<h4><strong>stack cookies(canaries) &amp; variable reordering</strong></h4>

<p><em>bf</em>最简单的攻击就是修改函数调用的return address，canaries即是在进入函数栈时在压入的return address之后再加入一个4位的随机数（canaries），如果攻击者改了return address那么canaries也会被改，那么系统在返回时将会报错。但是也有可能在函数返回之前调用一些函数变量，variable reordering则是将变量的顺序进行调整使得攻击者无法对本地变量进行overwrite，这两个技术都是靠编译器支持的，如果开启了这两种保护，栈上的结构将会变成这样：</p>

<p><img src="http://ytliu.info/images/2012-02-25-1.png" title="stack layout" alt="stack layout with or without GS protection" /></p>

<p>这两种机制的缺点很明显，对于canaries，它只能保护函数返回时的控制流变化，而且<em>canaries</em>也有可能被破解，对于<em>vr</em>它只支持有限种类的变量reordering，对于一些结构体的保护就不是很好。</p>

<h4><strong>SafeSEH</strong></h4>

<p>这是微软系统对于它们独特的<em>Exception handler</em>机制的保护，叫<em>Structured Exception Handler</em>，这里不想详细介绍，简单说就是在每个函数体的栈上除了一些本地变量之外还会存有一个叫做<em>Exception Handler Record</em>的东西，里面指向一个Exception Handler的链结构，当在函数执行过程中如果发生Exception，则会从这个record开始查找对应的handler。如果攻击者在overflow时将这个结构的handler的地址改成攻击代码的地址，则会在发生Exception时调用恶意代码。而SafeSEH用了两种方法<em>SEH handler validation</em>（维护一张表，在调用handler时检查是否是表中的合法handler）和<em>SEH chain validation</em>（enforce chain的一些特征使其在违反时能够被检查出来）。</p>

<h4><strong>Heap Protection</strong></h4>

<p>这是这篇文章的重点，因为我在这之前虽然听说过<em>heap overflow</em>，但也不清楚里面的细节，<a href="http://www.h-online.com/security/features/A-Heap-of-Risk-747161.html" title="a heap of risk">这篇文章</a>对此做了一个很详细的描述，这里简单介绍下:</p>

<p>文中举了个简单但是明了的例子，虽然不同系统中对heap的实现大同小异，但原理都是一样的。在本文的例子中，堆的结构是这样的：</p>

<p><img src="http://ytliu.info/images/2012-02-25-2.png" title="heap layout" alt="heap layout" /></p>

<p>每一个被回收的堆都有一个带有信息的头结构，里面包含了next, prev, size, used的信息，而在free操作过后都会有一个merge的操作，即将相邻的两个free的堆merge起来从而避免fragmentation，在这个merge操作中有一个非常关键的操作：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hdr->next->next->prev = hdr->next->prev;</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>而系统在计算<em>next->prev</em>时会先得到next的地址然后加4，于是攻击者就可以通过buffer overflow将堆的头结构改成以下内容（这里要说明下，heap的overflow可以通过integer的overflow来实现，具体可参阅文章前半部分）：</p>

<p><img src="http://ytliu.info/images/2012-02-25-3.png" title="heap header layout" alt="heap header layout" /></p>

<p>将next中的地址指向栈中存放<em>return address + 4</em>的地址，然后<em>next + 4</em>即为return address，将其地址通过那步关键操作赋值成攻击者注入的恶意代码的地址，即可达到目的。</p>

<p>heap overflow有一个最大的缺陷就是需要攻击者对系统堆的实现，以及一些内存信息非常了解，而且如果heap若也被标志为NX，则该方法也没有用了。</p>

<h4><strong>DEP（NX）</strong></h4>

<p><em>DEP</em>（Data Execution Prevention）即为通常所说的<em>NX</em>（Non-eXecutable），让除了代码段之外其它地方的数据都不能执行，这在很大程度上防止了攻击者注入的恶意代码的执行，但其有以下几点缺陷：</p>

<pre><code>    * 有些程序就是需要除了代码段的其它section的指令运行，如果用了该技术则会不兼容；
    * return-oriented &amp; return-to-libc攻击。
</code></pre>

<h4><strong>ASLR</strong></h4>

<p><em>ASLR</em>（Address Space Layout Randomization）对一些object的地址做随机化，使得攻击者很难准确地overflow正确的信息，但攻击者并非对此毫无办法：</p>

<pre><code>    * 可以猜测，或者用穷举的办法（JIT spraying就是一个很好的例子）；
    * 可以运行一些代码来获得随机规律；
    * 有时候并不需要知道确切的地址，只要知道相对值就行了。
</code></pre>

<hr />

<p>以上是对一些防范和攻击的简单介绍，这周还看了一篇paper叫</p>

<pre><code>    XFI: SOftware Guards for System Address Space
</code></pre>

<p>是由微软和UCB在OSDI'06发表的，应该说这是一篇很牛逼的文章，但是可能是因为我功力太浅，实在没怎么看懂，这里就将里面提出的7个properties列出来，如果有兴趣也可以参考MIT的<a href="http://pdos.csail.mit.edu/6.858/2011/lec/l03-xfi.txt">6.858课程lecture3</a>中对这篇文章提出的几个问题。</p>

<p><strong>external properties</strong>:</p>

<p><em>P1. memory-access constraints</em>: memory accesses are either into a). the memory of the XFI module, or b). into what host system has granted. read/write/execute handled separately, no write to XFI module's code</p>

<p><em>P2. interface restrictions</em>: control cannot flow out of XFI's code, except via calls to a set of prescribed support routines, and via returns to external call-site.</p>

<p><em>P3. scoped-stack integrity</em>: a). stack register points to at least a fixed amount of writable stack memory? b). accurately reflect function calls, returns and exception; c). Windows stack exception frames are well formed, and linked to each other.</p>

<p><em>P4. simplified instruction semantics</em>: certain machine-code instructions (dangerous, privileged instructions) can never be executed, certain other machine-code instructions may be executed only in a context taht constrains their effects.</p>

<p><em>P5. system-environment integrity</em>: certain aspects of system environment are subject to invariants.</p>

<p><strong>internal properties</strong>:</p>

<p><em>P6. control-flow integrity</em>: execution must follow a static, expected control-flow graph, even on computed calls and jumps.</p>

<p><em>P7. program-data integrity</em>: certain module-global and function-local variables can be accessed only via static references from the proper instructions in the XFI module.</p>

<p>文中之后所说的细节很多也都是通过<em>P6</em>和<em>P7</em>来保证整个系统7个properties的，所以说<em>control-flow integrity</em>和<em>data integrity</em>还是非常重要的，关于CFI，相信这一篇也是理解XFI的关键一文：</p>

<pre><code>    Contro-flow Integrity: Principles, Implementations, and Applications
</code></pre>

<p>打算在接下来的一周认真读一下。</p>

<p>另外还有一个由Robert C. Seacord做的presentation：</p>

<pre><code>    Pointer Subterfuge: Secure Coding in C and C++
</code></pre>

<p>也详细地介绍了在C和C++语言中可能出现的通过篡改pointer来实现攻击的例子，主要介绍了<em>GOT（Global Offset Table） Entries</em>, <em>The .dtors Section</em>, C++中的<em>Virtual Pointer</em>, <em>atexit()</em>和<em>on_exit()</em>, <em>setjump()</em>和<em>longjump()</em>，还有就是之前说的<em>SEH（Structured Exception Handler）</em>，在这个presentation里面详细介绍了它们的机制和用法，以及攻击者如何利用它们进行攻击的手段等等，是一篇很有趣的报告。</p>

<hr />

<p>然后简单讲下Oakland'11吧，上周把<em>IEEE Oakland'11</em>（四大安全会议之一，其余三个为ACM CCS, USENIX Security and ISOC NDSS）的paper简单浏览的一遍，根据题目挑选了20来篇看了下abstract和introduction，安全会议果然和系统相关会议有蛮大区别的，大部分paper主要是针对一个很小但是很具体的问题进行阐述并解决，不过说实话，我对里面的大部分都不是很有兴趣，但是里面一些paper提出来的一些概念，确实挺让我焕然一新，比如在Hardware Security的Section里面提到的硬件厂商或第三方的恶意backdoor，比如<em>HomeAlone</em>中利用Side-Channel来进行防范，还有之前说过的<em>Virtuoso</em>，<em>PRISM</em>中提到的和我们之前想过的细粒度权限控制的想法有着相似但不同称法的<em>Multi-Level Secure（MLS）</em>，以及<em>RePriv</em>中关于用户隐私性和个性化的平衡，还有那些当今比较热门的话题，如<em>Cashier-as-a-Service（CaaS）</em>、<em>Sybil Attack</em>、<em>Mobile Privacy（location privacy）</em>、<em>Side-Channel Attack</em>，甚至是我不是很感兴趣的<em>Formalization</em>，都让我对安全这个领域有了更进一步的了解。之后我又翻阅了下NDSS'12的paper，发现里面一些更让我感兴趣的知识，这也算是我下周的打算。</p>

<hr />

<p>总之下周注定要成为更忙的一周，重新奋斗hc，加上各种计划各种paper，凡事尽力吧，也无需勉强自己。</p>

<p>最后用这周译言上的那篇文章结尾：<a href="http://select.yeeyan.org/view/216596/248984" title="top five regrets of the dying">Top five regrets of the dying</a></p>

<p><blockquote><p>1. I wish I'd had the courage to live a life true to myself, not the life others expected of me;<br/>2. I wish I hadn't worked so hard;<br/>3. I wish I'd had the courge to express my feelings;<br/>4. I wish I had stayed in touch with my friends;<br/>5. I wish that I had let myself be happier.</p></blockquote></p>

<p>人生真的是如此短暂，"死而无憾"绝非易事，只希望在活着的时候对得起自己，不辜负亲人、朋友，其它的一切又算得了什么呢？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[paper reading: TCP RE and incremental MR]]></title>
    <link href="http://ytliu.github.com/blog/2011/12/26/paper-reading-tcp-re-and-incremental-mr/"/>
    <updated>2011-12-26T20:57:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2011/12/26/paper-reading-tcp-re-and-incremental-mr</id>
    <content type="html"><![CDATA[<p>今天组会两篇paper，Naruil讲的第一篇听了蛮有收获的，DX讲的第二篇感觉是自己英文太差而且领域不熟最后听的不是很懂，就大致记录下吧。</p>

<p>第一篇是一个做数据中心之间数据传递重复消除的系统，叫End-to-end RE(redundancy elimination)，是发在NSDI'11上的，题目叫"EndRE: An End-System Redundancy Elimination Service for Enterprises"，主要由微软的人做的。简单来说它的motivation就是现在在网络中传递的数据有很大一部分是重复的，比如两个包有大量的重复数据，而这些重复数据占用了大量的带宽，而这篇paper的工作就是如何在减少重复数据的同时也不减少太多的性能。</p>

<p>现在在用的关于这种重复数据消除的技术主要是"Middlebox-based"，它有几个缺点：  <br/>
*       关于安全方面的问题，网络数据在middlebox里面是明文，这样才能更好地判断重复性，这样就势必减弱了网络数据的安全级别；    <br/>
*       对于一些终端的手机设备，它需要和PC终端传递数据，在这过程中同样有数据的重复，而这种情况就不适宜用Middlebox技术了；      <br/>
*       代价比较大，现在用的middlebox都是很强大的服务器，配备巨大的内存来存储内容的cache。</p>

<p>于是作者就提出一种end-to-end的RE技术。通篇听下来最大的收获是对传统的fingerprint算法和作者提出的一种新的SAMPLEBYTE fingerprint算法的理解。</p>

<p>这篇paper里面提到了两种传统的fingerprint算法：</p>

<pre><code>    ModP fingerprint：
            这是一种content-based的fingerprint算法，用一种特殊的hash算法
            （每一个window的hash值 = 上一个window的hash值+上一个window的第一个byte+下一个byte）
            这样可以快速地得出每个window的hash值，之后将该hash值mod一个P，
            如果结果为0，则将该hash值作为一个sample的fingerprint。             
    Fixed fingerprint：
            这是一个position-based的fingerprint算法，即每隔P个byte算一个hash
            （window size大小的byte），之后将其作为一个sample的fingerprint。
</code></pre>

<p>从这两个fingerprint算法可以很容易地看出对于ModP，由于它是一个content-based的算法，所以不管是不是有偏移都可以比较完整地得出内容上的重复性，但是它的效率太低了，因为它要算每一个byte的hash；而对于Fixed，它的效率远远大于ModP，但消除重复性的能力也相应地变小很多。</p>

<!-- more -->


<p>于是作者提出提出的一种新的算法，叫SAMPLEBYTE fingerprint：</p>

<pre><code>    提供一个256bit的数组A，遍历要发送的包的每一个字节，比如第一个字节是0x23，那么查找
    数组A的第23个bit看它是否为1，如果为0则表示miss，继续查看后一个字节，如果为1则代表hit，
    即将这个字节以及后window size个大小算一个hash作为fingerprint，然后跳过（p/2）个字节
    （为了防止计算重复的hit）。
</code></pre>

<p>也就是说SAMPLEBYTE也是一个content-based的算法，而且跳过了每个byte都要检查的低效率从而达到更合理而又大粒度的sample机制。</p>

<p>这是这篇paper的核心算法，至于最后如何利用得出的fingerprint，则可以通过下张图看出：</p>

<p><img src="http://ytliu.info/images/2011-12-26-1.png" title="the overview of EndRE" alt="RE Overview" />
<img src="http://ytliu.info/images/2011-12-26-2.png" title="Look up in fingerprint hash table" alt="Look up in fingerprint hash table" /></p>

<p>在服务器端和客户端都要维护一个同步的cache，同时在服务器端有一个hash table，里面的key即为之前算出来的fingerprint，指向的是cache中的offset，当要传递一个包时，将算出的fingerprint在hash table里面查找，如果hit了，则从该fingerprint的第一个byte开始找出最大匹配的字符长度，从而省去了该重复内容的传递。而在客户端也只需要将接收到的内容按时间顺序写入cache中，保持和服务器的cache的同步性就好了。</p>

<p>另外，这个数据重复性消除的问题还需要考虑的很重要的一点就是：在客户端不该有很复杂的计算，否则直接将包压缩传递岂不更高效？</p>

<p>还有关于fingerprint算法和差抄袭算法的关系，问了下Naruil，他之前写的差抄袭算法也是用了fingerprint，不过用的是一个更健壮性的fingerprint算法，是基于一篇Sigmod'03的paper：<a href="http://dl.acm.org/citation.cfm?id=872770">Winnowing</a>。有机会可以去瞻仰下，据说效果相当好，反正我们这里的抄袭都是这么被检查出来的~</p>

<hr />

<p>另外一篇的题目是"Incoop: MapReduce for Incremental Computation"，发表在Socc'11上，做的是MapReduce上的Incremental computation。也就是说现在的MR架构对于两个输入，即使是有许多重复的输入也是从头开始重新计算一遍，而作者希望的是对于两个输入，对于不变的输入可以不再重复计算，而仅仅是变化的数据。因为DX是用英文说的，很多内容不是搞得太懂，只知道它用了"content-base chunking"和"reduce combiners"来分别解决stability和granularity的问题。至于具体的细节就搞不来了。</p>

<hr />

<p>The End.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Paper reading - Mobile security survey &amp; DS failure detection]]></title>
    <link href="http://ytliu.github.com/blog/2011/12/23/paper-reading-mobile-security-survey-and-ds-failure-detection/"/>
    <updated>2011-12-23T13:38:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2011/12/23/paper-reading-mobile-security-survey-and-ds-failure-detection</id>
    <content type="html"><![CDATA[<p>今天考坑爹的专题讲座，昨天组会的paper reading只能拖到现在写了。  <br/>
先稍微提下为什么要有这个section吧~我一直觉得自己进PPI一年半，开过的组会听过的paper到现在为止大部分都不记得了，效率太尼玛低下了！于是乎我就想把自己一些比较有感触的paper整理下，至少忘得会慢些吧~</p>

<p>好了，废话结束。进入正题。</p>

<p>昨天讲了两篇paper，一篇是S&amp;P的security section的，Z神讲的，这篇其实和我们现在的方向挺相关的，不过确实没有任何创新，是一片完完全全的survey，title is</p>

<pre><code>    "Mobile Security Catching up? Revealing the Nuts and Boits of the Security of Mobile Devices"
</code></pre>

<p>作者是Michael Becher，它介绍了现在手机上存在的一些安全问题，包括和Desktop的比较，以及一些attack model，比如：</p>

<pre><code>    Hardware-centric attack
            MITM attack - 中间人攻击
            JTAG attack
            forensic attack - 没听懂。。。
    Device-independent - 和普通服务器上的攻击差不多
    Software-centric attack
    user layer attack
</code></pre>

<p>其中，关于JTAG attack,
<blockquote><p>JTAG port is used for factory and field diagnostics and provides device-specific access to the internal flip-flops that store all the chip’s state.<br/>Since JTAG access gives the hardware equivalent of a software debugger, attackers have been using it from the beginning. The first attackers were probably competitors reverse engineering designs to copy them or improve their own. Currently, a packaged version of this attack has been in use for years to get free satellite TV.</p><footer><strong>@Nate Lawson</strong> <cite><a href='http://rdist.root.org/2007/04/06/jtag-attacks-and-pr-submarines'>rdist.root.org/2007/04/06/&hellip;</a></cite></footer></blockquote></p>

<p>还有关于Software-centric attack, 小Z讲了一个例子，比如说对iOS的pdf漏洞的良性利用，至于用来干嘛的，大家都懂得，jailbreak，不过其实我完全不知道这个是怎么样就得到root权限的，这几天研究下。</p>

<!-- more -->


<p>最后还有一点比较感兴趣的是小Z提到android的process isolation，我挺感兴趣的，它说android里面是用到context的概念进行进程间通讯，在kernel里面有一个binder进行管理，如果把kernel作为TPM那应该就没有什么安全问题了吧，不过其实还是存疑的，我不知道有没有一份关于android的安全机制的survey，上网搜了下，找到一篇宾大的"understand android security"，抽空看下。</p>

<p>其实这篇是一个完完全全的survey，小Z讲的也比较简单，不过其实手机的安全问题还是蛮多的，比如有提到的一个隐私的保护，有很多这方面的研究，比如通过限制控制流，比如TaintDroid，我想还有没有更强的机制呢？比如把Nicholai的histar用在手机上？</p>

<hr />

<p>另一篇是SOSP'11的</p>

<pre><code>    "Detecting Failures in Distributed Systems with the FALCON Spy Network"
</code></pre>

<p>其实是一篇想法很简单的paper，只不过之前的人没有把这个问题当做一个问题罢了。想法简单来说是这样的，现在在distributed system里面判断节点是否挂掉主要用的是end-to-end timeout机制，这样的缺点是发现节点挂掉可能会有比较长的延迟，比如说60s，那么在这60s里面机器A可能已经down掉了但却还被分配了任务从而造成availability变差，而这篇的目标就是：</p>

<pre><code>    Fast detection + reliability,
</code></pre>

<p>用的方法也很直接：gather inside information, avoid end-to-end timeout。相当于在运行应用程序主机的每一层跑一个spy（说白了就是和应用程序同个进程的一个线程），而每一层包括应用程序、OS、VMM，甚至是switch，用两个图就很容易理解：</p>

<p><img src="http://ytliu.info/images/2011-12-23-1.png" title="FALCON's Model" alt="FALCON's Model" />
<img src="http://ytliu.info/images/2011-12-23-2.png" title="FALCON's Implementation" alt="FALCON's Implementation" /></p>

<p>从后来的evaluation来看它的detection速度确实变小好多，CPU的overhead也很小，不过我觉得有两个问题：  <br/>
第一，在分布式系统中一台机器挂掉的几率可能很小，真的有必要为这么小的几率做一件这么复杂的事吗？比如原来是10秒钟检查到一个一个月才挂一次的机器现在用1秒钟来检查，却要付出一直用client和spy交互的代价？    <br/>
第二，如Model里每一层的spy都要和client端交互，那么网络带宽就要占用很多吧，为什么作者不测试网络带宽的占用率呢？CPU的overhead小可能是因为本来服务器的程序就不是CPU intensive的，但是确实IO intensive，那为什么不说下网络带宽被额外占用多少呢？还有，对于作者提出的架构来说，每一层spy与client的交互是走network的，如果用PV或HVM的话都得经过最下层的switch，那么按照作者的逻辑，既然其中一层的spy挂了就相当于全部挂了，那为什么不仅仅利用最下层的switch的spy提供的信息来判断呢？这样岂不是可以节省网络带宽？</p>

<p>The End.</p>
]]></content>
  </entry>
  
</feed>
