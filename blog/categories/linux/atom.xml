<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | Mctrain's Blog]]></title>
  <link href="http://ytliu.github.com/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://ytliu.github.com/"/>
  <updated>2013-05-01T11:19:24+08:00</updated>
  <id>http://ytliu.github.com/</id>
  <author>
    <name><![CDATA[Liu Yutao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[系统调用学习笔记 - ptrace和wait]]></title>
    <link href="http://ytliu.github.com/blog/2013/04/30/xi-tong-diao-yong-xue-xi-bi-ji-ptrace/"/>
    <updated>2013-04-30T09:46:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/04/30/xi-tong-diao-yong-xue-xi-bi-ji-ptrace</id>
    <content type="html"><![CDATA[<p>在系统安全这门课上讲到ptrace这个系统调用，我马上想到当年做CFIMon里面用到的ptrace:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">child</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * force the task to stop before executing the first</span>
</span><span class='line'><span class="cm"> * user level instruction</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_TRACEME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">......</span>
</span><span class='line'>
</span><span class='line'><span class="n">execvp</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arg</span><span class="p">);</span>
</span><span class='line'><span class="cm">/* not reached */</span>
</span><span class='line'><span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>然后在parent的代码里面：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * wait for the child to exec</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">ret</span> <span class="o">=</span> <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">status</span><span class="p">,</span> <span class="n">WUNTRACED</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">WIFEXITED</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
</span><span class='line'>    <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;task %s [%d] exited already status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pid</span><span class="p">,</span> <span class="n">WEXITSTATUS</span><span class="p">(</span><span class="n">status</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="p">......</span>
</span><span class='line'>
</span><span class='line'><span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="n">perf_event_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hw</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">buf</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">map_size</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">......</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * effectively activate monitoring</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_CONT</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">......</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>先是waitpid，等待child调用execv，之后设置一系列参数（在这里是打开perf_event，并mmap一段内存区域），然后调用ptrace让child继续执行。</p>

<p>其实到现在为止我也还不是很清楚ptrace的用法和waitpid那几个参数的意思，于是想好好学习下，在google上搜到了一篇翻译的<a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_i/">玩转ptrace1</a>和<a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_ii/">2</a>，这里归纳整理下，另外，在IBM的<a href="https://www.ibm.com/developerworks/cn/">developerWorks</a>上找到一篇介绍进程相关，以及waitpid的<a href="http://www.ibm.com/developerworks/cn/linux/kernel/syscall/part3/">博文</a>，也一起学习了。</p>

<!-- more -->


<hr />

<h3>僵尸进程和wait</h3>

<p>在linux中，当一个进程退出（如调用exit等）后，并不是马上完全消失掉了，它还会留下一些踪迹，成为一个僵尸进程（Zombie）。作为一个僵尸进程来说，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。在僵尸进程记录了这个进程是怎么死亡的（是正常退出呢，还是出现了错误，还是被其它进程强迫退出的？），以及它占用的总系统CPU时间和总用户CPU时间分别是多少？还有发生页错误的数目和收到信号的数目等。</p>

<p>而wait和waitpid这两个系统调用就是用来收集这些信息，并使得这个僵尸进程永远消失的。</p>

<p>这两个系统调用的原型是这样子的：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="cp">#include &amp;lt;sys/wait.h&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="n">pid_t</span> <span class="n">wait</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="n">pit_t</span> <span class="n">wait</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span><span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">,</span><span class="kt">int</span> <span class="n">options</span><span class="p">);</span><span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>对于wait来说，它是等待所有的子进程的退出， 而对比来看，waitpid增加了两个参数<code>pid</code>和<code>option</code>。</p>

<p>对于pid来说，有四种情况：</p>

<table>
<thead>
<tr>
<th align="left">pid         </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">pid == -1   </td>
<td align="left"> 等待任一个子进程（与wait等效）；</td>
</tr>
<tr>
<td align="left">pid > 0     </td>
<td align="left"> 则等待其进程ID与pid相等的子进程。</td>
</tr>
<tr>
<td align="left">pid == 0    </td>
<td align="left"> 等待其组ID等于调用进程组ID的任一个子进程。</td>
</tr>
<tr>
<td align="left">pid &lt; -1    </td>
<td align="left"> 等待其组ID等于pid绝对值的任一子进程。</td>
</tr>
</tbody>
</table>


<p>另外，如果参数status的值不是NULL，wait就会把子进程退出时的状态取出并存入其中，这是一个整数值，指出了子进程是正常退出还是被非正常结束的，以及正常结束时的返回值，或被哪一个信号结束的等信息。有一套专门的宏（macro）来对其进行操作：</p>

<table>
<thead>
<tr>
<th align="left">macro               </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">WIFEXITED(status)   </td>
<td align="left"> 若子进程是正常退出的，则为真，此时可以调用WEXITSTATUS(status)获得退出值</td>
</tr>
<tr>
<td align="left">WEXITSTATUS(status) </td>
<td align="left"> 若子进程是被异常终止的，则为真，此时可以调用WTERMSIG(status)获得使其终止的信号编号</td>
</tr>
<tr>
<td align="left">WIFSTOPPED(status)  </td>
<td align="left"> 若子进程是暂停状态，则为真，此时可以调用WTERMSIG(status)获得使其暂停的信号编号</td>
</tr>
</tbody>
</table>


<p>到现在为止，还有一个参数叫option，它提供了一些额外的选项来控制waitpid，目前在Linux中只支持WNOHANG和WUNTRACED两个选项：</p>

<table>
<thead>
<tr>
<th align="left">Option      </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">WNOHANG     </td>
<td align="left"> waitpid在调用时发现没有已退出的子进程可收集，则返回0</td>
</tr>
<tr>
<td align="left">WUNTRACED   </td>
<td align="left"> 在所有符合条件的pid中，如果其中有已经stopped的进程，则立即返回（而对于traced的进程，即使没有该选项，如果其stopped了，也会立即返回）</td>
</tr>
</tbody>
</table>


<hr />

<h3>ptrace笔记</h3>

<p>ptrace可以做很多事，比如可以在用户层拦截和修改系统调用，在每次系统调用的时候改变子进程中的寄存器和内核映像，实现断点调试和系统调用的跟踪等等，具体的可以看玩转ptrace<a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_i/">1</a>和<a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_ii/">2</a>。这里对ptrace进行一个总结：</p>

<p>ptrace这个系统调用的作用是允许一个进程（the tracing process）来跟踪和控制另外一个进程（the traced process）。它的原型是这样的：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">sys</span><span class="o">/</span><span class="n">ptrace</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">long</span> <span class="n">ptrace</span><span class="p">(</span><span class="k">enum</span> <span class="n">__ptrace_request</span> <span class="n">request</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">data</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>第一个参数<code>request</code>决定了ptrace的行为与其它参数的使用方法，它可以有好多值，以下列出了几种比较常见的取值：</p>

<table>
<thead>
<tr>
<th align="left">request             </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">PTRACE_TRACEME      </td>
<td align="left"> 由子进程调用，让父进程跟踪自己（pid, addr, and data are ignored）</td>
</tr>
<tr>
<td align="left">PTRACE_PEEKTEXT     </td>
<td align="left"> 读取内存地址addr的值（data is ignored）</td>
</tr>
<tr>
<td align="left">PTRACE_PEEKDATA     </td>
<td align="left"> 同PTRACE_PEEKTEXT    </td>
</tr>
<tr>
<td align="left">PTRACE_PEEKUSER     </td>
<td align="left"> 读取tracee's USER area的addr位移的数据（data is ignored）</td>
</tr>
<tr>
<td align="left">PTRACE_POKETEXT     </td>
<td align="left"> 将data中的值写入addr内存地址中</td>
</tr>
<tr>
<td align="left">PTRACE_POKEDATA     </td>
<td align="left"> 同PTRACE_POKETEXT</td>
</tr>
<tr>
<td align="left">PTRACE_POKEUSER     </td>
<td align="left"> 将data中的值写入tracee's USER area的addr位移地址中</td>
</tr>
<tr>
<td align="left">PTRACE_GETREGS      </td>
<td align="left"> 将general-purpose寄存器写入data（addr is ignored）</td>
</tr>
<tr>
<td align="left">PTRACE_GETFPREGS    </td>
<td align="left"> 将 floating-point寄存器写入data（addr is ignored）</td>
</tr>
<tr>
<td align="left">PTRACE_SETREGS      </td>
<td align="left"> 修改tracee的general-purpose寄存器（addr is ignored)</td>
</tr>
<tr>
<td align="left">PTRACE_SETFPREGS    </td>
<td align="left"> 修改tracee的floating-point寄存器（addr is ignored)</td>
</tr>
<tr>
<td align="left">PTRACE_CONT         </td>
<td align="left"> 重启之前暂停的进程，如果data不为零，则代表发给进程的信号值（addr is ignored）</td>
</tr>
<tr>
<td align="left">PTRACE_SYSCALL,     </td>
<td align="left"> 执行PTRACE_CONT，并且使进程进入syscall-enter-stop和syscall-exit-stop模式</td>
</tr>
<tr>
<td align="left">PTRACE_SINGLESTEP   </td>
<td align="left"> 执行PTRACE_CONT，并且进行单点跟踪</td>
</tr>
<tr>
<td align="left">PTRACE_ATTACH       </td>
<td align="left"> 发送一个SIGSTOP信号到pid进程，并开始进行跟踪（addr and data are ignored）</td>
</tr>
<tr>
<td align="left">PTRACE_DETACH       </td>
<td align="left"> 先detach，然后执行PTRACE_CONT。</td>
</tr>
</tbody>
</table>


<p>除此之外，还有很多可用的取值，在linux的<a href="http://linux.die.net/man/2/ptrace">manpage</a>里面有很详细的描述。</p>

<p>需要注意的是，这里所说的attach和之后的一系列操作都是针对<strong>thread</strong>而言的，对于多线程来说，每一个thread都可以单独地被attach到一个跟踪者（tracer）。</p>

<p>在<a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_i/">玩转ptrace1</a>中举了一个很有趣的例子，可以通过这个例子来理解这些request都是怎么用的。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">sys</span><span class="o">/</span><span class="n">ptrace</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">sys</span><span class="o">/</span><span class="n">types</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">sys</span><span class="o">/</span><span class="n">wait</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">unistd</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">linux</span><span class="o">/</span><span class="n">user</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">sys</span><span class="o">/</span><span class="n">syscall</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">const</span> <span class="kt">int</span> <span class="n">long_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">reverse</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>   <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">char</span> <span class="n">temp</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">temp</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>    <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'>    <span class="n">str</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span><span class='line'><span class="kt">void</span> <span class="n">getdata</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">child</span><span class="p">,</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>         <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">{</span>   <span class="kt">char</span> <span class="o">*</span><span class="n">laddr</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'><span class="k">union</span> <span class="n">u</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">char</span> <span class="n">chars</span><span class="p">[</span><span class="n">long_size</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span><span class="n">data</span><span class="p">;</span>
</span><span class='line'><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">j</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">long_size</span><span class="p">;</span>
</span><span class='line'><span class="n">laddr</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">data</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span>
</span><span class='line'>                      <span class="n">child</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span>
</span><span class='line'>                      <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>    <span class="n">memcpy</span><span class="p">(</span><span class="n">laddr</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">chars</span><span class="p">,</span> <span class="n">long_size</span><span class="p">);</span>
</span><span class='line'>    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="n">laddr</span> <span class="o">+=</span> <span class="n">long_size</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">j</span> <span class="o">=</span> <span class="n">len</span> <span class="o">%</span> <span class="n">long_size</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">data</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span>
</span><span class='line'>                      <span class="n">child</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span>
</span><span class='line'>                      <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>    <span class="n">memcpy</span><span class="p">(</span><span class="n">laddr</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">chars</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">str</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span><span class='line'><span class="kt">void</span> <span class="n">putdata</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">child</span><span class="p">,</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>         <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">{</span>   <span class="kt">char</span> <span class="o">*</span><span class="n">laddr</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'><span class="k">union</span> <span class="n">u</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">char</span> <span class="n">chars</span><span class="p">[</span><span class="n">long_size</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span><span class="n">data</span><span class="p">;</span>
</span><span class='line'><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">j</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">long_size</span><span class="p">;</span>
</span><span class='line'><span class="n">laddr</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">chars</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span> <span class="n">long_size</span><span class="p">);</span>
</span><span class='line'>    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKEDATA</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span>
</span><span class='line'>           <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
</span><span class='line'>    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="n">laddr</span> <span class="o">+=</span> <span class="n">long_size</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">j</span> <span class="o">=</span> <span class="n">len</span> <span class="o">%</span> <span class="n">long_size</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">chars</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
</span><span class='line'>    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKEDATA</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span>
</span><span class='line'>           <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="n">pid_t</span> <span class="n">child</span><span class="p">;</span>
</span><span class='line'>   <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
</span><span class='line'>   <span class="k">if</span><span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_TRACEME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>  <span class="n">execl</span><span class="p">(</span><span class="s">&quot;/bin/ls&quot;</span><span class="p">,</span> <span class="s">&quot;ls&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>   <span class="p">}</span>
</span><span class='line'>   <span class="k">else</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="kt">long</span> <span class="n">orig_eax</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">long</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="o">*</span><span class="n">laddr</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">toggle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="n">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">status</span><span class="p">);</span>
</span><span class='line'>     <span class="k">if</span><span class="p">(</span><span class="n">WIFEXITED</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
</span><span class='line'>         <span class="k">break</span><span class="p">;</span>
</span><span class='line'>     <span class="n">orig_eax</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKUSER</span><span class="p">,</span>
</span><span class='line'>                       <span class="n">child</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">ORIG_EAX</span><span class="p">,</span>
</span><span class='line'>                       <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>     <span class="k">if</span><span class="p">(</span><span class="n">orig_eax</span> <span class="o">==</span> <span class="n">SYS_write</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">toggle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>           <span class="n">toggle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>           <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKUSER</span><span class="p">,</span>
</span><span class='line'>                              <span class="n">child</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">EBX</span><span class="p">,</span>
</span><span class='line'>                              <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>           <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKUSER</span><span class="p">,</span>
</span><span class='line'>                              <span class="n">child</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">ECX</span><span class="p">,</span>
</span><span class='line'>                              <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>           <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKUSER</span><span class="p">,</span>
</span><span class='line'>                              <span class="n">child</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">EDX</span><span class="p">,</span>
</span><span class='line'>                              <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>           <span class="n">str</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">((</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>                             <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
</span><span class='line'>           <span class="n">getdata</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">str</span><span class="p">,</span>
</span><span class='line'>                   <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span><span class='line'>           <span class="n">reverse</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</span><span class='line'>           <span class="n">putdata</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">str</span><span class="p">,</span>
</span><span class='line'>                   <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>           <span class="n">toggle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SYSCALL</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>   <span class="p">}</span>
</span><span class='line'>   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>首先子进程调用</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_TRACEME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>来让父进程跟踪自己，当然，这个也可以通过在父进程中调用</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_ATTACH</span><span class="p">,</span> <span class="n">traced_process_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>来实现，之后子进程运行了<code>bin/ls</code>。当子进程发生系统调用的时候会将控制权转交入父进程，父进程通过</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">orig_eax</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKUSER</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">ORIG_EAX</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>来获得eax寄存器的值（从而判断调用的是哪个系统调用），之后继续通过<code>PTRACE_PEEKUSER</code>这个request来获得SYS_write系统调用的其它参数(ebx, ecx, edx)，当然，这个步骤还可以用</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">linux</span><span class="o">/</span><span class="n">user</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">struct</span> <span class="n">user_regs_struct</span> <span class="n">regs</span><span class="p">;</span>
</span><span class='line'><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">regs</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>来替代，从而得到所有的寄存器的值regs。</p>

<p>之后，父进程在getdata函数中通过</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">data</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>将文件名从ecx中获得，并在putdata函数中通过</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKEDATA</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>将反转后的字符串写入寄存器ecx中，从而是的打出来的文件名是反转了的。</p>

<p>最后，通过调用</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SYSCALL</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>将控制权返还给子进程，同时让其进入syscall-enter-stop和syscall-exit-stop模式，即在进入和退出system call的时候都会stop，并将控制权交给父进程。</p>

<p>这里有一个问题，就是当子进程调用PTRACE_TRACEME或者父进程调用PTRACE_ATTACH之后，在什么情况下会将子进程stop（从而将控制权交给父进程）呢？</p>

<p>要回答这个问题，首先要知道当我们使用ptrace的时候，内核中发生了什么？这里有一段简要的说明：当一个进程调用了 ptrace(PTRACE_TRACEME, …)之后，内核为该进程设置了一个标记，注明该进程将被跟踪。内核中的相关原代码（位于<code>arch/i386/kernel/ptrace.c</code>）如下：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="n">PTRACE_TRACEME</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="cm">/* are we already being traced? */</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">ptrace</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">PT_PTRACED</span><span class="p">)</span>
</span><span class='line'>    <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span><span class='line'><span class="cm">/* set the ptrace bit in the process flags. */</span>
</span><span class='line'><span class="n">current</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">ptrace</span> <span class="o">|=</span> <span class="n">PT_PTRACED</span><span class="p">;</span>
</span><span class='line'><span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>一次系统调用完成之后，内核察看那个标记，然后执行trace系统调用（如果这个进程正处于被跟踪状态的话）。其汇编的细节可以在 <code>arch/i386/kernel/entry.S</code>中找到。</p>

<p>现在让我们来看看这个sys_trace()函数（位于<code>arch/i386/kernel/ptrace.c</code>）。它停止子进程，然后发送一个信号给父进程，告诉它子进程已经停滞，这个信号会激活正处于等待状态的父进程，让父进程进行相关处理。父进程在完成相关操作以后就调用ptrace(PTRACE_CONT, …)或者 ptrace(PTRACE_SYSCALL, …)，这将唤醒子进程，内核此时所作的是调用一个叫<code>wake_up_process()</code>的进程调度函数。其他的一些系统架构可能会通过发送SIGCHLD给子进程来达到这个目的。</p>

<hr />

<p>由此可以看出，通过ptrace和wait(waitpid)等系统调用，可以使得父进程在系统调用的级别做子进程的跟踪和检查，由此来做很多的事情，但是有一个问题是，由于ptrace并不能指定哪些系统调用被跟踪，因此所有系统调用都会被stop并且转移控制权，由此会产生比较大的overhead。</p>

<p>总的来说，ptrace是一个非常强大的系统调用，这里只是介绍了其中几个比较常用的参数，更多的信息可以参照<a href="http://linux.die.net/man/2/ptrace">ptrace的manpage</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[系统调用学习笔记 - Linux系统调用表（转）]]></title>
    <link href="http://ytliu.github.com/blog/2013/04/28/xi-tong-diao-yong-xue-xi-bi-ji-linuxxi-tong-diao-yong-biao-%28zhuan-%29/"/>
    <updated>2013-04-28T20:56:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/04/28/xi-tong-diao-yong-xue-xi-bi-ji-linuxxi-tong-diao-yong-biao-(zhuan-)</id>
    <content type="html"><![CDATA[<p>最近发现自己对Linux里面很多的系统调用都不清楚具体是在怎么回事儿，想要好好学习一下。</p>

<p>在IBM的<a href="https://www.ibm.com/developerworks/cn/">developerWorks</a>中发现一份它们整理的<a href="http://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html">Linux系统调用列表</a>，从进程控制，文件系统控制等八个方面列举了大部分常见的Linux系统调用：</p>

<!-- more -->


<h2>进程控制</h2>

<table>
<thead>
<tr>
<th align="center">System Call             </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">fork                    </td>
<td align="left"> 创建一个新进程</td>
</tr>
<tr>
<td align="center">clone                   </td>
<td align="left"> 按指定条件创建子进程</td>
</tr>
<tr>
<td align="center">execve                  </td>
<td align="left"> 运行可执行文件</td>
</tr>
<tr>
<td align="center">exit                    </td>
<td align="left"> 中止进程</td>
</tr>
<tr>
<td align="center">_exit                   </td>
<td align="left"> 立即中止当前进程</td>
</tr>
<tr>
<td align="center">getdtablesize           </td>
<td align="left"> 进程所能打开的最大文件数</td>
</tr>
<tr>
<td align="center">getpgid                 </td>
<td align="left"> 获取指定进程组标识号</td>
</tr>
<tr>
<td align="center">setpgid                 </td>
<td align="left"> 设置指定进程组标志号</td>
</tr>
<tr>
<td align="center">getpgrp                 </td>
<td align="left"> 获取当前进程组标识号</td>
</tr>
<tr>
<td align="center">setpgrp                 </td>
<td align="left"> 设置当前进程组标志号</td>
</tr>
<tr>
<td align="center">getpid                  </td>
<td align="left"> 获取进程标识号</td>
</tr>
<tr>
<td align="center">getppid                 </td>
<td align="left"> 获取父进程标识号</td>
</tr>
<tr>
<td align="center">getpriority             </td>
<td align="left"> 获取调度优先级</td>
</tr>
<tr>
<td align="center">setpriority             </td>
<td align="left"> 设置调度优先级</td>
</tr>
<tr>
<td align="center">modify_ldt              </td>
<td align="left"> 读写进程的本地描述表</td>
</tr>
<tr>
<td align="center">nanosleep               </td>
<td align="left"> 使进程睡眠指定的时间</td>
</tr>
<tr>
<td align="center">nice                    </td>
<td align="left"> 改变分时进程的优先级</td>
</tr>
<tr>
<td align="center">pause                   </td>
<td align="left"> 挂起进程，等待信号</td>
</tr>
<tr>
<td align="center">personality             </td>
<td align="left"> 设置进程运行域</td>
</tr>
<tr>
<td align="center">prctl                   </td>
<td align="left"> 对进程进行特定操作</td>
</tr>
<tr>
<td align="center">ptrace                  </td>
<td align="left"> 进程跟踪</td>
</tr>
<tr>
<td align="center">sched_get_priority_max  </td>
<td align="left"> 取得静态优先级的上限</td>
</tr>
<tr>
<td align="center">sched_get_priority_min  </td>
<td align="left"> 取得静态优先级的下限</td>
</tr>
<tr>
<td align="center">sched_getparam          </td>
<td align="left"> 取得进程的调度参数</td>
</tr>
<tr>
<td align="center">sched_getscheduler      </td>
<td align="left"> 取得指定进程的调度策略</td>
</tr>
<tr>
<td align="center">sched_rr_get_interval   </td>
<td align="left"> 取得按RR算法调度的实时进程的时间片长度</td>
</tr>
<tr>
<td align="center">sched_setparam          </td>
<td align="left"> 设置进程的调度参数</td>
</tr>
<tr>
<td align="center">sched_setscheduler      </td>
<td align="left"> 设置指定进程的调度策略和参数</td>
</tr>
<tr>
<td align="center">sched_yield             </td>
<td align="left"> 进程主动让出处理器,并将自己等候调度队列队尾</td>
</tr>
<tr>
<td align="center">vfork                   </td>
<td align="left"> 创建一个子进程，以供执行新程序，常与execve等同时使用</td>
</tr>
<tr>
<td align="center">wait                    </td>
<td align="left"> 等待子进程终止</td>
</tr>
<tr>
<td align="center">wait3                   </td>
<td align="left"> 参见wait</td>
</tr>
<tr>
<td align="center">waitpid                 </td>
<td align="left"> 等待指定子进程终止</td>
</tr>
<tr>
<td align="center">wait4                   </td>
<td align="left"> 参见waitpid</td>
</tr>
<tr>
<td align="center">capget                  </td>
<td align="left"> 获取进程权限</td>
</tr>
<tr>
<td align="center">capset                  </td>
<td align="left"> 设置进程权限</td>
</tr>
<tr>
<td align="center">getsid                  </td>
<td align="left"> 获取会晤标识号</td>
</tr>
<tr>
<td align="center">setsid                  </td>
<td align="left"> 设置会晤标识号</td>
</tr>
</tbody>
</table>


<h2>文件系统控制</h2>

<h4>文件读写操作</h4>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">fcntl         </td>
<td align="left"> 文件控制</td>
</tr>
<tr>
<td align="center">open          </td>
<td align="left"> 打开文件</td>
</tr>
<tr>
<td align="center">creat         </td>
<td align="left"> 创建新文件</td>
</tr>
<tr>
<td align="center">close         </td>
<td align="left"> 关闭文件描述字</td>
</tr>
<tr>
<td align="center">read          </td>
<td align="left"> 读文件</td>
</tr>
<tr>
<td align="center">write         </td>
<td align="left"> 写文件</td>
</tr>
<tr>
<td align="center">readv         </td>
<td align="left"> 从文件读入数据到缓冲数组中</td>
</tr>
<tr>
<td align="center">writev        </td>
<td align="left"> 将缓冲数组里的数据写入文件</td>
</tr>
<tr>
<td align="center">pread         </td>
<td align="left"> 对文件随机读</td>
</tr>
<tr>
<td align="center">pwrite        </td>
<td align="left"> 对文件随机写</td>
</tr>
<tr>
<td align="center">lseek         </td>
<td align="left"> 移动文件指针</td>
</tr>
<tr>
<td align="center">_llseek       </td>
<td align="left"> 在64位地址空间里移动文件指针</td>
</tr>
<tr>
<td align="center">dup           </td>
<td align="left"> 复制已打开的文件描述字</td>
</tr>
<tr>
<td align="center">dup2          </td>
<td align="left"> 按指定条件复制文件描述字</td>
</tr>
<tr>
<td align="center">flock         </td>
<td align="left"> 文件加/解锁</td>
</tr>
<tr>
<td align="center">poll          </td>
<td align="left"> I/O多路转换</td>
</tr>
<tr>
<td align="center">truncate      </td>
<td align="left"> 截断文件</td>
</tr>
<tr>
<td align="center">ftruncate     </td>
<td align="left"> 参见truncate</td>
</tr>
<tr>
<td align="center">umask         </td>
<td align="left"> 设置文件权限掩码</td>
</tr>
<tr>
<td align="center">fsync         </td>
<td align="left"> 把文件在内存中的部分写回磁盘</td>
</tr>
</tbody>
</table>


<h4>文件系统操作</h4>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">access        </td>
<td align="left"> 确定文件的可存取性</td>
</tr>
<tr>
<td align="center">chdir         </td>
<td align="left"> 改变当前工作目录</td>
</tr>
<tr>
<td align="center">fchdir        </td>
<td align="left"> 参见chdir</td>
</tr>
<tr>
<td align="center">chmod         </td>
<td align="left"> 改变文件方式</td>
</tr>
<tr>
<td align="center">fchmod        </td>
<td align="left"> 参见chmod</td>
</tr>
<tr>
<td align="center">chown         </td>
<td align="left"> 改变文件的属主或用户组</td>
</tr>
<tr>
<td align="center">fchown        </td>
<td align="left"> 参见chown</td>
</tr>
<tr>
<td align="center">lchown        </td>
<td align="left"> 参见chown</td>
</tr>
<tr>
<td align="center">chroot        </td>
<td align="left"> 改变根目录</td>
</tr>
<tr>
<td align="center">stat          </td>
<td align="left"> 取文件状态信息</td>
</tr>
<tr>
<td align="center">lstat         </td>
<td align="left"> 参见stat</td>
</tr>
<tr>
<td align="center">fstat         </td>
<td align="left"> 参见stat</td>
</tr>
<tr>
<td align="center">statfs        </td>
<td align="left"> 取文件系统信息</td>
</tr>
<tr>
<td align="center">fstatfs       </td>
<td align="left"> 参见statfs</td>
</tr>
<tr>
<td align="center">readdir       </td>
<td align="left"> 读取目录项</td>
</tr>
<tr>
<td align="center">getdents      </td>
<td align="left"> 读取目录项</td>
</tr>
<tr>
<td align="center">mkdir         </td>
<td align="left"> 创建目录</td>
</tr>
<tr>
<td align="center">mknod         </td>
<td align="left"> 创建索引节点</td>
</tr>
<tr>
<td align="center">rmdir         </td>
<td align="left"> 删除目录</td>
</tr>
<tr>
<td align="center">rename        </td>
<td align="left"> 文件改名</td>
</tr>
<tr>
<td align="center">link          </td>
<td align="left"> 创建链接</td>
</tr>
<tr>
<td align="center">symlink       </td>
<td align="left"> 创建符号链接</td>
</tr>
<tr>
<td align="center">unlink        </td>
<td align="left"> 删除链接</td>
</tr>
<tr>
<td align="center">readlink      </td>
<td align="left"> 读符号链接的值</td>
</tr>
<tr>
<td align="center">mount         </td>
<td align="left"> 安装文件系统</td>
</tr>
<tr>
<td align="center">umount        </td>
<td align="left"> 卸下文件系统</td>
</tr>
<tr>
<td align="center">ustat         </td>
<td align="left"> 取文件系统信息</td>
</tr>
<tr>
<td align="center">utime         </td>
<td align="left"> 改变文件的访问修改时间</td>
</tr>
<tr>
<td align="center">utimes        </td>
<td align="left"> 参见utime</td>
</tr>
<tr>
<td align="center">quotactl      </td>
<td align="left"> 控制磁盘配额</td>
</tr>
</tbody>
</table>


<h2>系统控制</h2>

<table>
<thead>
<tr>
<th align="center">System Call         </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">ioctl               </td>
<td align="left"> I/O总控制函数</td>
</tr>
<tr>
<td align="center">_sysctl             </td>
<td align="left"> 读/写系统参数</td>
</tr>
<tr>
<td align="center">acct                </td>
<td align="left"> 启用或禁止进程记账</td>
</tr>
<tr>
<td align="center">getrlimit           </td>
<td align="left"> 获取系统资源上限</td>
</tr>
<tr>
<td align="center">setrlimit           </td>
<td align="left"> 设置系统资源上限</td>
</tr>
<tr>
<td align="center">getrusage           </td>
<td align="left"> 获取系统资源使用情况</td>
</tr>
<tr>
<td align="center">uselib              </td>
<td align="left"> 选择要使用的二进制函数库</td>
</tr>
<tr>
<td align="center">ioperm              </td>
<td align="left"> 设置端口I/O权限</td>
</tr>
<tr>
<td align="center">iopl                </td>
<td align="left"> 改变进程I/O权限级别</td>
</tr>
<tr>
<td align="center">outb                </td>
<td align="left"> 低级端口操作</td>
</tr>
<tr>
<td align="center">reboot              </td>
<td align="left"> 重新启动</td>
</tr>
<tr>
<td align="center">swapon              </td>
<td align="left"> 打开交换文件和设备</td>
</tr>
<tr>
<td align="center">swapoff             </td>
<td align="left"> 关闭交换文件和设备</td>
</tr>
<tr>
<td align="center">bdflush             </td>
<td align="left"> 控制bdflush守护进程</td>
</tr>
<tr>
<td align="center">sysfs               </td>
<td align="left"> 取核心支持的文件系统类型</td>
</tr>
<tr>
<td align="center">sysinfo             </td>
<td align="left"> 取得系统信息</td>
</tr>
<tr>
<td align="center">adjtimex            </td>
<td align="left"> 调整系统时钟</td>
</tr>
<tr>
<td align="center">alarm               </td>
<td align="left"> 设置进程的闹钟</td>
</tr>
<tr>
<td align="center">getitimer           </td>
<td align="left"> 获取计时器值</td>
</tr>
<tr>
<td align="center">setitimer           </td>
<td align="left"> 设置计时器值</td>
</tr>
<tr>
<td align="center">gettimeofday        </td>
<td align="left"> 取时间和时区</td>
</tr>
<tr>
<td align="center">settimeofday        </td>
<td align="left"> 设置时间和时区</td>
</tr>
<tr>
<td align="center">stime               </td>
<td align="left"> 设置系统日期和时间</td>
</tr>
<tr>
<td align="center">time                </td>
<td align="left"> 取得系统时间</td>
</tr>
<tr>
<td align="center">times               </td>
<td align="left"> 取进程运行时间</td>
</tr>
<tr>
<td align="center">uname               </td>
<td align="left"> 获取当前UNIX系统的名称、版本和主机等信息</td>
</tr>
<tr>
<td align="center">vhangup             </td>
<td align="left"> 挂起当前终端</td>
</tr>
<tr>
<td align="center">nfsservctl          </td>
<td align="left"> 对NFS守护进程进行控制</td>
</tr>
<tr>
<td align="center">vm86                </td>
<td align="left"> 进入模拟8086模式</td>
</tr>
<tr>
<td align="center">create_module       </td>
<td align="left"> 创建可装载的模块项</td>
</tr>
<tr>
<td align="center">delete_module       </td>
<td align="left"> 删除可装载的模块项</td>
</tr>
<tr>
<td align="center">init_module         </td>
<td align="left"> 初始化模块</td>
</tr>
<tr>
<td align="center">query_module        </td>
<td align="left"> 查询模块信息</td>
</tr>
<tr>
<td align="center">*get_kernel_syms    </td>
<td align="left"> 取得核心符号,已被query_module代替</td>
</tr>
</tbody>
</table>


<h2>内存管理</h2>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">brk           </td>
<td align="left"> 改变数据段空间的分配</td>
</tr>
<tr>
<td align="center">sbrk          </td>
<td align="left"> 参见brk</td>
</tr>
<tr>
<td align="center">mlock         </td>
<td align="left"> 内存页面加锁</td>
</tr>
<tr>
<td align="center">munlock       </td>
<td align="left"> 内存页面解锁</td>
</tr>
<tr>
<td align="center">mlockall      </td>
<td align="left"> 调用进程所有内存页面加锁</td>
</tr>
<tr>
<td align="center">munlockall    </td>
<td align="left"> 调用进程所有内存页面解锁</td>
</tr>
<tr>
<td align="center">mmap          </td>
<td align="left"> 映射虚拟内存页</td>
</tr>
<tr>
<td align="center">munmap        </td>
<td align="left"> 去除内存页映射</td>
</tr>
<tr>
<td align="center">mremap        </td>
<td align="left"> 重新映射虚拟内存地址</td>
</tr>
<tr>
<td align="center">msync         </td>
<td align="left"> 将映射内存中的数据写回磁盘</td>
</tr>
<tr>
<td align="center">mprotect      </td>
<td align="left"> 设置内存映像保护</td>
</tr>
<tr>
<td align="center">getpagesize   </td>
<td align="left"> 获取页面大小</td>
</tr>
<tr>
<td align="center">sync          </td>
<td align="left"> 将内存缓冲区数据写回硬盘</td>
</tr>
<tr>
<td align="center">cacheflush    </td>
<td align="left"> 将指定缓冲区中的内容写回磁盘</td>
</tr>
</tbody>
</table>


<h2>网络管理</h2>

<table>
<thead>
<tr>
<th align="center">System Call     </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">getdomainname   </td>
<td align="left"> 取域名</td>
</tr>
<tr>
<td align="center">setdomainname   </td>
<td align="left"> 设置域名</td>
</tr>
<tr>
<td align="center">gethostid       </td>
<td align="left"> 获取主机标识号</td>
</tr>
<tr>
<td align="center">sethostid       </td>
<td align="left"> 设置主机标识号</td>
</tr>
<tr>
<td align="center">gethostname     </td>
<td align="left"> 获取本主机名称</td>
</tr>
<tr>
<td align="center">sethostname     </td>
<td align="left"> 设置主机名称</td>
</tr>
</tbody>
</table>


<h2>Socket控制</h2>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">socketcall    </td>
<td align="left"> socket系统调用</td>
</tr>
<tr>
<td align="center">socket        </td>
<td align="left"> 建立socket</td>
</tr>
<tr>
<td align="center">bind          </td>
<td align="left"> 绑定socket到端口</td>
</tr>
<tr>
<td align="center">connect       </td>
<td align="left"> 连接远程主机</td>
</tr>
<tr>
<td align="center">accept        </td>
<td align="left"> 响应socket连接请求</td>
</tr>
<tr>
<td align="center">send          </td>
<td align="left"> 通过socket发送信息</td>
</tr>
<tr>
<td align="center">sendto        </td>
<td align="left"> 发送UDP信息</td>
</tr>
<tr>
<td align="center">sendmsg       </td>
<td align="left"> 参见send</td>
</tr>
<tr>
<td align="center">recv          </td>
<td align="left"> 通过socket接收信息</td>
</tr>
<tr>
<td align="center">recvfrom      </td>
<td align="left"> 接收UDP信息</td>
</tr>
<tr>
<td align="center">recvmsg       </td>
<td align="left"> 参见recv</td>
</tr>
<tr>
<td align="center">listen        </td>
<td align="left"> 监听socket端口</td>
</tr>
<tr>
<td align="center">select        </td>
<td align="left"> 对多路同步I/O进行轮询</td>
</tr>
<tr>
<td align="center">shutdown      </td>
<td align="left"> 关闭socket上的连接</td>
</tr>
<tr>
<td align="center">getsockname   </td>
<td align="left"> 取得本地socket名字</td>
</tr>
<tr>
<td align="center">getpeername   </td>
<td align="left"> 获取通信对方的socket名字</td>
</tr>
<tr>
<td align="center">getsockopt    </td>
<td align="left"> 取端口设置</td>
</tr>
<tr>
<td align="center">setsockopt    </td>
<td align="left"> 设置端口参数</td>
</tr>
<tr>
<td align="center">sendfile      </td>
<td align="left"> 在文件或端口间传输数据</td>
</tr>
<tr>
<td align="center">socketpair    </td>
<td align="left"> 创建一对已联接的无名socket</td>
</tr>
</tbody>
</table>


<h2>用户管理</h2>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">getuid        </td>
<td align="left"> 获取用户标识号</td>
</tr>
<tr>
<td align="center">setuid        </td>
<td align="left"> 设置用户标志号</td>
</tr>
<tr>
<td align="center">getgid        </td>
<td align="left"> 获取组标识号</td>
</tr>
<tr>
<td align="center">setgid        </td>
<td align="left"> 设置组标志号</td>
</tr>
<tr>
<td align="center">getegid       </td>
<td align="left"> 获取有效组标识号</td>
</tr>
<tr>
<td align="center">setegid       </td>
<td align="left"> 设置有效组标识号</td>
</tr>
<tr>
<td align="center">geteuid       </td>
<td align="left"> 获取有效用户标识号</td>
</tr>
<tr>
<td align="center">seteuid       </td>
<td align="left"> 设置有效用户标识号</td>
</tr>
<tr>
<td align="center">setregid      </td>
<td align="left"> 分别设置真实和有效的的组标识号</td>
</tr>
<tr>
<td align="center">setreuid      </td>
<td align="left"> 分别设置真实和有效的用户标识号</td>
</tr>
<tr>
<td align="center">getresgid     </td>
<td align="left"> 分别获取真实的,有效的和保存过的组标识号</td>
</tr>
<tr>
<td align="center">setresgid     </td>
<td align="left"> 分别设置真实的,有效的和保存过的组标识号</td>
</tr>
<tr>
<td align="center">getresuid     </td>
<td align="left"> 分别获取真实的,有效的和保存过的用户标识号</td>
</tr>
<tr>
<td align="center">setresuid     </td>
<td align="left"> 分别设置真实的,有效的和保存过的用户标识号</td>
</tr>
<tr>
<td align="center">setfsgid      </td>
<td align="left"> 设置文件系统检查时使用的组标识号</td>
</tr>
<tr>
<td align="center">setfsuid      </td>
<td align="left"> 设置文件系统检查时使用的用户标识号</td>
</tr>
<tr>
<td align="center">getgroups     </td>
<td align="left"> 获取后补组标志清单</td>
</tr>
<tr>
<td align="center">setgroups     </td>
<td align="left"> 设置后补组标志清单</td>
</tr>
</tbody>
</table>


<h2>进程间通信</h2>

<h4>信号</h4>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">sigaction     </td>
<td align="left"> 设置对指定信号的处理方法</td>
</tr>
<tr>
<td align="center">sigprocmask   </td>
<td align="left"> 根据参数对信号集中的信号执行阻塞/解除阻塞等操作</td>
</tr>
<tr>
<td align="center">sigpending    </td>
<td align="left"> 为指定的被阻塞信号设置队列</td>
</tr>
<tr>
<td align="center">sigsuspend    </td>
<td align="left"> 挂起进程等待特定信号</td>
</tr>
<tr>
<td align="center">signal        </td>
<td align="left"> 参见signal</td>
</tr>
<tr>
<td align="center">kill          </td>
<td align="left"> 向进程或进程组发信号</td>
</tr>
<tr>
<td align="center">*sigblock     </td>
<td align="left"> 向被阻塞信号掩码中添加信号,已被sigprocmask代替</td>
</tr>
<tr>
<td align="center">*siggetmask   </td>
<td align="left"> 取得现有阻塞信号掩码,已被sigprocmask代替</td>
</tr>
<tr>
<td align="center">*sigsetmask   </td>
<td align="left"> 用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替</td>
</tr>
<tr>
<td align="center">*sigmask      </td>
<td align="left"> 将给定的信号转化为掩码,已被sigprocmask代替</td>
</tr>
<tr>
<td align="center">*sigpause     </td>
<td align="left"> 作用同sigsuspend,已被sigsuspend代替</td>
</tr>
<tr>
<td align="center">sigvec        </td>
<td align="left"> 为兼容BSD而设的信号处理函数,作用类似sigaction</td>
</tr>
<tr>
<td align="center">ssetmask      </td>
<td align="left"> ANSI C的信号处理函数,作用类似sigaction</td>
</tr>
</tbody>
</table>


<h4>消息</h4>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">msgctl        </td>
<td align="left"> 消息控制操作</td>
</tr>
<tr>
<td align="center">msgget        </td>
<td align="left"> 获取消息队列</td>
</tr>
<tr>
<td align="center">msgsnd        </td>
<td align="left"> 发消息</td>
</tr>
<tr>
<td align="center">msgrcv        </td>
<td align="left"> 取消息</td>
</tr>
</tbody>
</table>


<h4>管道</h4>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">pipe          </td>
<td align="left"> 创建管道</td>
</tr>
</tbody>
</table>


<h4>信号量</h4>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">semctl        </td>
<td align="left"> 信号量控制</td>
</tr>
<tr>
<td align="center">semget        </td>
<td align="left"> 获取一组信号量</td>
</tr>
<tr>
<td align="center">semop         </td>
<td align="left"> 信号量操作</td>
</tr>
</tbody>
</table>


<h4>共享内存</h4>

<table>
<thead>
<tr>
<th align="center">System Call   </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">shmctl        </td>
<td align="left"> 控制共享内存</td>
</tr>
<tr>
<td align="center">shmget        </td>
<td align="left"> 获取共享内存</td>
</tr>
<tr>
<td align="center">shmat         </td>
<td align="left"> 连接共享内存</td>
</tr>
<tr>
<td align="center">shmdt         </td>
<td align="left"> 拆卸共享内存</td>
</tr>
</tbody>
</table>


<p>后面会慢慢对其中的某些进行详细的学习。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【转】计算机的启动]]></title>
    <link href="http://ytliu.github.com/blog/2013/02/17/%5B%28zhuan-%29%5D-ji-suan-ji-de-qi-dong/"/>
    <updated>2013-02-17T14:24:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/02/17/[(zhuan-)]-ji-suan-ji-de-qi-dong</id>
    <content type="html"><![CDATA[<p>寒假回来就要开始执行新年的计划了~首先是每周的一篇blog。</p>

<p>今天看了<a href="http://www.ruanyifeng.com/blog/">阮一峰</a>最新的一篇博客<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的</a>，感觉写得很好，又清楚又简单。虽然自己关于计算机启动这个过程从大三OS课的时候就陆陆续续地一直有了解，但是都没有一个系统的了解，或者了解了又忘了，希望通过这次记录把这点彻底弄清楚来并且记在脑子里。另外在评论中有另外一个小哥<a href="http://www.dalei.org/">大磊</a>把他的<a href="http://www.dalei.org/linux-unix-boot-process/">博客</a>也贴出来了，写得很详细，作为阮一峰的补充吧。</p>

<!-- more -->


<hr />

<p>以下是转来的文章，中间加上了大磊的补充，也没有区分哪句话是谁说的，具体的还是看之前提到的两篇博客吧：</p>

<h4>零、boot的含义</h4>

<p>先问一个问题，"启动"用英语怎么说？</p>

<p>回答是boot。可是，boot原来的意思是靴子，"启动"与靴子有什么关系呢？ 原来，这里的boot是bootstrap（鞋带）的缩写，它来自一句谚语：</p>

<pre><code>"pull oneself up by one's bootstraps"
</code></pre>

<p>字面意思是"拽着鞋带把自己拉起来"，这当然是不可能的事情。最早的时候，工程师们用它来比喻，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！</p>

<p>早期真的是这样，必须想尽各种办法，把一小段程序装进内存，然后计算机才能正常运行。所以，工程师们把这个过程叫做"拉鞋带"，久而久之就简称为boot了。</p>

<p>计算机的整个启动过程分成四个阶段。</p>

<h4>一、第一阶段：BIOS</h4>

<p>上个世纪70年代初，"只读内存"（read-only memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-1.png" title="BIOS" alt="BIOS" /></p>

<p>这块芯片里的程序叫做"基本輸出輸入系統"（Basic Input/Output System），简称为BIOS。</p>

<h5>1.1 硬件自检</h5>

<p>BIOS中主要存放的程序包括：自诊断程序（通过读取CMOS RAM中的内容识别硬件配置，并对其进行自检和初始化）、CMOS设置程序（引导过程中，通过特殊热键启动，进行设置后，存入CMOS RAM中）、系统自动装载程序（在系统自检成功后，将磁盘相对0道0扇区上的引导程序装入内存使其运行）和主要I/O驱动程序和中断服务（BIOS和硬件直接打交道，需要加载I/O驱动程序）。</p>

<p>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做"硬件自检"（Power-On Self-Test），缩写为POST。</p>

<p>如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</p>

<h5>1.2 启动顺序</h5>

<p>硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。</p>

<p>这时，BIOS需要知道，"下一阶段的启动程序"具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做"启动顺序"（Boot Sequence）。</p>

<p>打开BIOS的操作界面，里面有一项就是"设定启动顺序"。</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-2.png" title="BIOS Sequence" alt="BIOS Sequence" /></p>

<h4>二、第二阶段：主引导记录</h4>

<p>BIOS按照"启动顺序"，把控制权转交给排在第一位的储存设备。即根据用户指定的引导顺序从软盘、硬盘或是可移动设备中读取启动设备的MBR，并放入指定的位置（0x7c000）内存中。</p>

<p>这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给"启动顺序"中的下一个设备。</p>

<p>这最前面的512个字节，就叫做"主引导记录"（Master boot record，缩写为MBR）。</p>

<h5>2.1 主引导记录的结构</h5>

<p>"主引导记录"只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。</p>

<p>主引导记录由三个部分组成：</p>

<pre><code>（1） 第1-446字节：调用操作系统的机器码。
（2） 第447-510字节：分区表（Partition table）。
（3） 第511-512字节：主引导记录签名（0x55和0xAA）。
</code></pre>

<p>其中，第二部分"分区表"的作用，是将硬盘分成若干个区。</p>

<h5>2.2 分区表</h5>

<p>硬盘分区有很多好处。考虑到每个区可以安装不同的操作系统，"主引导记录"因此必须知道将控制权转交给哪个区。</p>

<p>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做"主分区"。</p>

<p>每个主分区的16个字节，由6个部分组成：</p>

<pre><code>（1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。
（2） 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。
（3） 第5个字节：主分区类型。
（4） 第6-8个字节：主分区最后一个扇区的物理位置。
（5） 第9-12字节：该主分区第一个扇区的逻辑地址。
（6） 第13-16字节：主分区的扇区总数。
</code></pre>

<p>最后的四个字节（"主分区的扇区总数"），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。</p>

<p>如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。</p>

<h4>三、第三阶段：硬盘启动</h4>

<p>这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。</p>

<h5>3.1 情况A：卷引导记录</h5>

<p>上一节提到，四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做"卷引导记录"（Volume boot record，缩写为VBR）。</p>

<p>"卷引导记录"的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。</p>

<h5>3.2 情况B：扩展分区和逻辑分区</h5>

<p>随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成"扩展分区"（Extended partition）。</p>

<p>所谓"扩展分区"，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做"逻辑分区"（logical partition）。</p>

<p>计算机先读取扩展分区的第一个扇区，叫做"扩展引导记录"（Extended boot record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。</p>

<p>计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。</p>

<p>但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。</p>

<h5>3.3 情况C：启动管理器</h5>

<p>在这种情况下，计算机读取"主引导记录"前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的"启动管理器"（boot loader），由用户选择启动哪一个操作系统。</p>

<p>Linux环境中，目前最流行的启动管理器是Grub。</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-3.png" title="Grub" alt="Grub" /></p>

<p>对于grub而言，在MBR中的446字节的引导程序属于GRUB的开始执行程序，通过这段程序，进一步执行stage1.5或是stage2的执行程序，将在下面详细介绍执行过程。</p>

<p>其中stage1.5或是stage2便属于阶段2引导的过程了，stage2过程也是作为GRUB kernel的核心代码出现。Stage1.5过程（对于GRUB而言存在stage1.5，GRUB2则不存在）的功能很单一，主要就是为了引导stage2过程服务。由于stage2过程的代码存放在文件系统下的boot分区目录中，因此stage1.5过程就是需要提供一个文件系统的环境，而该文件系统环境需要保证系统可以找到stage2过程的文件，那么stage1.5阶段提供的文件系统需要是boot文件系统所对应的，这个在执行grub install过程中就已经确定了。stage2过程中，主要会把系统切换到保护模式，设置好C运行时环境，找到config文件（事实上就是menulist文件），如果没有找到就执行一个shell，等待用户的执行。然后的工作就变成了输入命令->解析命令->执行命令的循环中。当然该阶段引导的最终状态就是执行boot命令，将内核和initrd镜像加载进入内存中，进而将控制权转交给内核。</p>

<h4>四、第四阶段：操作系统</h4>

<p>控制权转交给操作系统后，操作系统的内核首先被载入内存。</p>

<p>以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。</p>

<p>然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。</p>

<p>至此，全部启动过程完成。</p>

<hr />

<p>另外在大磊的<a href="http://www.dalei.org/linux-unix-boot-process/">博客</a>中还有许多细节部分：</p>

<h4>BIOS启动细节：</h4>

<p>a) 按下电源开关，电源就开始向主板和其它设备供电；当芯片组检测到电源已经开始稳定供电了(当然从不稳定到稳定的过程只是一瞬间的事情)，它便撤去RESET信号(如果是手工按下计算机面板上的Reset按钮来重启机器，那么松开该按钮时芯片组就会撤去RESET信号)；CPU马上就从地址FFFF:0000H 处开始执行指令，放在这里的只是一条跳转指令，跳到系统BIOS中真正的启动代码处。</p>

<p>b) 系统BIOS的启动代码首先进行POST(Power－On Self Test，加电后自检)。POST的主要检测系统中一些关键设备是否存在和能否正常工作，例如内存和显卡等设备；由于POST是最早进行的检测过程，此时显卡还没有初始化，如果系统BIOS在进行POST的过程中发现了一些致命错误，例如没有找到内存或者内存有问题(此时只会检查640K常规内存)，那么系统BIOS就会直接控制喇叭发声来报告错误，声音的长短和次数代表了错误的类型；在正常情况下，POST过程进行得非常快，几乎无法感觉到它的存在。POST结束之后就会调用其它代码来进行更完整的硬件检测。</p>

<p>c) 接下来系统BIOS将查找显卡的BIOS。前面说过，存放显卡BIOS的ROM芯片的起始地址通常设在C0000H处，系统BIOS在这个地方找到显卡BIOS之后就调用它的初始化代码，由显卡BIOS来初始化显卡。此时多数显卡都会在屏幕上显示出一些初始化信息，介绍生产厂商、图形芯片类型等内容，不过这个画面几乎是一闪而过。系统BIOS接着会查找其它设备的BIOS程序，找到之后同样要调用这些BIOS内部的初始化代码来初始化相关的设备。</p>

<p>d) 查找完所有其它设备的BIOS之后，系统BIOS将显示出它自己的启动画面，其中包括有系统BIOS的类型、序列号和版本号等内容。</p>

<p>e) 接着系统BIOS将检测和显示CPU的类型和工作频率，测试所有的RAM，并同时在屏幕上显示内存测试的进度。可以在CMOS设置中自行决定使用简单耗时少或者详细耗时多的测试方式。</p>

<p>f) 内存测试通过之后，系统BIOS将开始检测系统中安装的一些标准硬件设备，包括硬盘、CD-ROM、串口、并口和软驱等设备，另外绝大多数较新版本的系统BIOS在这一过程中还要自动检测和设置内存的定时参数、硬盘参数和访问模式等。</p>

<p>g) 标准设备检测完毕后，系统BIOS内部支持即插即用的代码将开始检测和配置系统中安装的即插即用设备。每找到一个设备之后，系统BIOS都会在屏幕上显示出设备的名称和型号等信息，同时为该设备分配中断、DMA通道和I/O端口等资源。</p>

<p>h) 到这一步为止，所有硬件都已经检测配置完毕了，多数系统BIOS会重新清屏并在屏幕上方显示出一个表格，其中概略地列出了系统中安装的各种标准硬件设备，以及它们使用的资源和一些相关工作参数。</p>

<p>i) 接下来系统BIOS将更新ESCD(Extended System Configuration Data，扩展系统配置数据)。ESCD是系统BIOS用来与操作系统交换硬件配置信息的一种手段，这些数据被存放在CMOS(一小块特殊的RAM，由主板上的电池来供电)之中。通常ESCD数据只在系统硬件配置发生改变后才会更新，所以不是每次启动机器时都能够看到“Update ESCD… Success”这样的信息。不过，某些主板的系统BIOS在保存ESCD数据时使用了与Windows 9x不相同的数据格式，于是Windows 9x在它自己的启动过程中会把ESCD数据修改成自己的格式。但在下一次启动机器时，即使硬件配置没有发生改变，系统BIOS也会把ESCD的数据格式改回来。如此循环，将会导致在每次启动机器时，系统BIOS都要更新一遍ESCD，这就是为什么有些机器在每次启动时都会显示出相关信息的原因。</p>

<p>j) ESCD更新完毕后，系统BIOS的启动代码将进行它的最后一项工作：即根据用户指定的启动顺序从软盘、硬盘或光驱启动MBR。在这个过程中会按照启动顺序顺序比较其放置MBR的位置的结尾两位是否为0xAA55，通过这种方式判断从哪个引导设备进行引导。在确定之后，将该引导设备的MBR内容读入到0x7C00[1]的位置，并再次判断其最后两位，当检测正确之后，进行阶段1的引导。</p>

<h4>EFI启动细节</h4>

<p>与传统MBR相比，GPT采用了不同的分区方式。</p>

<p>对于传统MBR，其结构主要如下：</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-4.png" title="BIOS Graph" alt="BIOS Graph" /></p>

<p>上图即对上文中所述的很形象的说明，在图中看到MBR被分成三个部分，分别是：Bootloader、分别表以及Magic Number。其中Bootloader部分为stage1中被执行的起始部分。</p>

<p>相反，对于EFI系统中所采用的GPT分区方式，则采用了不同于MBR分区方式的形式，从下图中可以发现：</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-5.png" title="EFI Graph" alt="EFI Graph" /></p>

<p>如上图所示，GPT分区表主要包括：保护MBR、首要GPT头、首要GPT、备用GPT、备用GPT头和磁盘数据区。保护MBR与正常的MBR区别不大，主要是分区表上的不同，在保护MBR中只要一个表示为0xEE的分区，以此来表示这块硬盘使用GPT分区表。首要GPT头包含了众多信息，具体内容如下：</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-6.png" title="EFI Table" alt="EFI Table" /></p>

<p>分区表头定义了硬盘的可用空间以及组成分区表的项的大小和数量。分区表头还记录了这块硬盘的GUID，记录了分区表头本身的位置和大小（位置总是在LBA1）以及备份分区表头和分区表的位置和大小（在硬盘的最后）。它还存储着它本身和分区表的CRC32校验。固件、引导程序和操作系统在启动时可以根据这个校验值来判断分区表是否有错误，如果出错了，可以使用软件从硬盘最后的备份GPT分区表恢复整个分区表，如果备份GPT也校验错误，那么磁盘将不可用，系统拒绝启动。</p>

<p>接下来主要是128个分区表项，GPT分区表使用简单而直接的方式表示分区。一个分区表项的前16字节是分区类型GUID。例如，EFI系统分区的GUID类型是{C12A7328-F81F-11D2-BA4B-00A0C93EC93B} 。接下来的16字节是该分区的唯一的GUID（这个指的是该分区本身，而之前的GUID指的是该分区的类型）。在接下来是分区其实和末尾的64位LBA编号，以及分区的名字和属性。具体结构如下表：</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-7.png" title="EFI Table2" alt="EFI Table2" /></p>

<h4>MBR引导</h4>

<p>接下来开始真正的引导过程了，主要说明GRUP的引导。总体上GRUB更像是一个mini os，只不过这个mini os的作用只是加载其他的操作系统，在GRUB中包括stage1、stage1.5（可选）和stage2，其中stage1和stage1.5属于boot loader，stage2属于mini os的内核部分。GRUB中stage1过程主要位于MBR的前446字节中（对于支持GPT分区的磁盘，同样有最开始的512字节作为保护MBR，保护MBR与正常的MBR区别不大，主要是分区表上的不同，在保护MBR中只要一个表示为0xEE的分区，以此来表示这块硬盘使用GPT分区表，不能识别GPT硬盘的操作系统通常会识别出一个未知类型的分区，并且拒绝对硬盘进行操作），之后的64字节为硬盘的分区表，最后两个字节为MBR结束标志位（0xAA55）。</p>

<p>stage1部分占用了446字节，其代码文件是源码目录下stage1/stage1.S文件，汇编后生成一个512字节的boot.img，被写在硬盘的0面0道1扇区中，作为硬盘的MBR。stage1的工作很简单，就是加载0面0道2扇区上的512字节到0×8000，然后跳转到0×8000执行。</p>

<p>在0面0道2扇区上的512字节内容为<code>stage1/start.S</code>文件汇编后生成。该扇区上的内容的作用是加载stage1.5或是stage2过程，并将控制权转交。</p>

<h4>Grub引导</h4>

<p>在start过程将控制权转交后，接下来就是GRUB的核心过程了。该过程之所以区分stage1.5和stage2，主要原因是GRUB和GRUB2的区别。在GRUB2中，将stage1.5过程集成到了stage2的过程中，所以stage1.5过程仅仅是针对GRUB的。下面将会分别介绍两种GRUB版本的两种过程。</p>

<p>4.1 GRUB中stage1.5过程</p>

<p>Stage1.5过程很无辜，它的作用很单一，但是非常关键。它的主要功用就是构造一个boot分区系统对应的文件系统，这样可以通过文件系统的路径（/boot/grub/）寻找stage2过程需要的core.img，进而加载到内存中开始执行。</p>

<p>Stage1.5存在于0面0道3扇区开始的地方，并一直延续十几k字节的区域，具体的大小与相应的文件系统的大小有关（文中涉及到了0面0道1-3+x扇区，这部分扇区为保留扇区，BIOS不会放置任何数据。正因为如此如果转换到GPT分区形式，系统将不能被正确引导，如上文所示，MBR后面的扇区都被其他内容所占据）。Stage1.5过程被构建成多种不同类型，但是功能类似，下面简单介绍一下基本的stage1.5过程的文件系统。e2fs_stage1_5（针对ext2fs，可引导ext2和ext3文件系统）、fat_stage1_5（针对fat文件系统，可引导fat32和fat16）、ffs_stage1_5、jfs_stage1_5、minix_stage1_5、reiserfs_stage1_5、vstafs_stage1_5和xfs_stage1_5，这些文件被称为stage1.5过程，这些文件每个至少都在11k以上。除此之外还有两个比较特殊的文件，分别为nbgrub和pxegrub，这两个文件主要是在网络引导时使用，只是格式不同而已，他们很类似与stage2，只是需要建立网络来获取配置文件。</p>

<p>由于stage1.5过程中会涉及到多个文件系统对应的文件，因此本文中主要以ext2fs为例进行说明，其他文件系统与此类似，可以同样进行分析理解。</p>

<p>对于ext2fs文件系统，用于生成该文件系统的stage1.5过程文件（e2fs_stage1_5）的代码为<code>stage2/fsys_ext2fs.c</code>文件。</p>

<p>在<code>stage2/filesys.h</code>文件中定义了每个文件系统对外的接口，用于上层调用，作为stage2过程寻找核心代码使用，文件系统一般被定义的接口主要就是三个函数，分别是mount、read和dir函数。对应ext2fs，其定义的函数为：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">ifdef</span> <span class="n">FSYS_EXT2FS</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">FSYS_EXT2FS_NUM</span> <span class="mi">1</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">ext2fs_mount</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="n">ext2fs_read</span> <span class="p">(</span><span class="kt">char</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="n">ext2fs_dir</span> <span class="p">(</span><span class="kt">char</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">dirname</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="k">else</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">FSYS_EXT2FS_NUM</span> <span class="mi">0</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">endif</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>针对ext2fs有如上的函数名称，每个函数将具体在<code>stage2/fsys_ext2fs.c</code>文件中被定义，这里面没有包含任何的写的过程，对于bootloader而言仅仅读就可以完成任务了，没必要对其系统进行写操作。其中ext2fs_mount函数用于检查文件系统类型，并将superblock读入到内存中；ext2fs_read函数和ext2fs_dir函数用于对文件系统具体的操作。在<code>stage2/fsys_ext2fs.c</code>文件中除了需要对这三个函数的定义之外，还需要文件系统的属性的数据结构（superblock、inode和group结构，这些结构最初被定义在<code>include/linux/ext2_fs.h</code>文件中），通过这些数据结构描述一个文件系统。</p>

<p>如果读者有兴趣可以试着创建新的文件系统的支持，可以参照目前存在的一些文件系统的模板（实例）编写。</p>

<p>4.2 GRUB中stage2过程</p>

<p>GRUB中的核心过程也就是stage2过程了，该过程主要是在文件系统建立以后选择合适的操作系统进行加载并转交控制权，达到最后引导操作系统的目标。由于GRUB属于multi boot loader，因此在引导的时候要进行选择，选择哪种操作系统来运行。在GRUB内部主要包括两种方式，首先是从menu.list中读取显示到屏幕让用户选择，其次是通过grub-shell中定义的命令手动进行启动。本文将在后面介绍这两种方式如何运行，接下来先介绍一下stage2的具体的执行过程。</p>

<p>在上面一节中介绍过，stage1.5过程中将boot分区的文件系统加载了，之后又做了一件事情，就是将控制权转交给stage2，而stage2入口的地方就是<code>stage2/asm.S</code>文件。<code>Stage2/asm.S</code>文件属于汇编代码，主要作用是初始化C语言的运行环境，为下面执行C语言的函数做好准备，在准备好之后，将执行init_bios_info(<code>stage2/common.c</code>)函数。init_bios_info函数的作用是执行一些底层的函数，然后跳转到cmain执行，cmain函数位于<code>stage2/stage2.c</code>文件中。cmain函数内部进行一个死循环，在循环内部首先加载配置文件，显示给用户，在这同时循环一个内层循环，在内层循环中，获取配置文件中的命令，并解析执行。过程中如果没有可用的配置文件，那么进入命令行模式（enter_cmdline函数），如果找到可用的menu，那么开始执行menu的对应的内容（run_menu函数）。</p>

<p>对于enter_cmdline（<code>stage2/stage2.c</code>）函数，将调用find_command（<code>stage2/cmdline.c</code>），进而执行相应命令的函数。</p>

<p>对于run_menu（<code>stage2/stage2.c</code>）函数，将调用<code>stage2/cmdline.c</code>文件中的run_script函数，进而调用find_command，执行相应命令的函数。</p>

<p>这两种方式虽然经过了不同的过程，对用户输入的行为进行分析和处理，最终调用的函数为find_command，在该函数中顺序循环比较“输入”的命令是否与系统内部定义的相同，如果相同转到执行该函数。在这个比较的过程中包含了一个全局的数据结构为struct builtin（<code>stage2/shared.h</code>），由该数据结构组成了一个table类型（<code>stage2/builtins.c</code>），将命令与相对应的builtin结构对应一起并进行串联。下面描述一下builtin结构的定义：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">builtin</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="cm">/* 命令名称，重要，是搜索命令时的依据*/</span>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span><span class='line'><span class="cm">/* 命令函数，重要，是搜索匹配后调用的函数*/</span>
</span><span class='line'><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span><span class='line'><span class="cm">/* 功能标示，一般未用到. */</span>
</span><span class='line'><span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'><span class="cm">/* 简短帮助信息*/</span>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">short_doc</span><span class="p">;</span>
</span><span class='line'><span class="cm">/* 完整帮助信息*/</span>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">long_doc</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">};</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">struct</span> <span class="n">builtin</span> <span class="o">*</span><span class="n">builtin_table</span><span class="p">[]</span><span class="err">；</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>有兴趣的读者可以对上面的内容进行扩展，形成自己的命令，主要在<code>stage2/builtins.c</code>文件中按照预定的格式更新，并添加到builtin_table中即可。</p>

<p>在上面打开配置文件的过程中，主要是通过一些文件操作函数（被定义在<code>stage2/disk_io.c</code>中）完成。这些文件操作函数主要包括：grub_open、grub_read、grub_seek和grub_close等，这些函数属于grub对外的上层接口，具体的函数内部将调用前文中提到的boot分区对应的文件系统的相应的函数完成，这个过程主要是通过回调函数来完成。该过程整体思路类似于面向对象过程，通过对象操作具体的函数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic Linker]]></title>
    <link href="http://ytliu.github.com/blog/2012/12/15/dynamic-linker/"/>
    <updated>2012-12-15T13:03:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/12/15/dynamic-linker</id>
    <content type="html"><![CDATA[<p>在了解dynamic linker之前，得先对ELF文件有一个初步的了解：</p>

<p>在<a href="http://www.jollen.org/blog/2006/12/enabling_dynamic_loader_1.html" title="elf">jollen</a>的博客中有一断对ELF Session的表格:</p>

<p><img src="http://ytliu.github.com/images/2012-12-09-1.png" title="elf section" alt="elf section" /></p>

<p>很有参考价值。其中将会涉及到的sections有<em>.got</em>, <em>.plt</em>, <em>.interp</em>。</p>

<p>另外在<a href="http://www.bottomupcs.com/" title="computer science from bottom up">Computer Science from the Bottom Up</a>中有一章对dynamic linker进行了详细的说明。</p>

<p>以下的内容很多来自于该文档和俞甲子的《程序员的自我修养》一书第七章。</p>

<!-- more -->


<p>问题的产生是这样子的：当我们使用一段shared library的时候，它并没有指定说一定要把相应的代码放在哪个内存地址，而是由dynamic linker根据当前内存情况选择一段最合适的内存区域用于放置相应的code和data。那么dynamic linker是怎么做的呢？我们举一个很简单的例子来说明；</p>

<p>首先，我们编写并编译一段动态链接库lib.c, lib.h：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span> <span class="s">&quot;lib.h&quot;</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">void</span> <span class="n">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;in dynamic lib, i is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">Char</span> <span class="o">*</span><span class="n">dylib</span> <span class="o">=</span> <span class="s">&quot;Test Dynamic Linker String&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">test</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>然后将其编译为动态连接库libtest.so</p>

<pre><code>$ gcc -fPIC -shared -o libtest.so lib.c
</code></pre>

<p>这里 "-shared"表示产生共享对象，"-fPIC"表示地址无关代码，这在后面会说。</p>

<p>然后我们编写一段程序dytest.c来利用libtest.so:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span> <span class="s">&quot;lib.h&quot;</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dylib</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dylib</span><span class="p">);</span>
</span><span class='line'><span class="n">test</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>然后对其进行编译：</p>

<pre><code>$ gcc -o dytest dytest.c ./libtest.so
$ ./dytest
Hello, Test Dynamic Linker String
in dynamic lib, i is 5
</code></pre>

<p>就这么一段简单的测试代码中，动态链接是怎么完成的呢？它和静态链接有什么不同呢？</p>

<p>在静态链接中，整个程序只有一个可执行文件，在这个可执行文件中，所有变量和函数的地址都已经固定好了（这是由linker在链接时从静态链接的文件中读出来并进行地址重定位），而在动态链接中，这些地址并不会进行地址重定位。那么，链接器怎么知道一个地址是静态符号还是动态符号呢？其实在我们编译dytest的时候也将libtest.so加进去进行编译了，而在libtest.so中保存了完整的符号信息，从而linker可以知道该符号是一个动态符号。</p>

<p>既然动态链接库主要用于共享，那么有一个问题：共享对象在编译时不应该假设自己在进程虚拟地址空间中的位置。一种解决的方法是采用“装载时重定位”，但是这样有一个缺点，因为它要在程序装载时对指令部分进行修改，所以就无法使得指令部分在多个进程中共享，这样就失去了共享库的优势，另一种就是地址无关代码，它的基本想法就是把指令中那些需要修改的部分分离出来，和数据放在一起。</p>

<p>我们把地址引用分为4个部分</p>

<ul>
<li>模块内部函数调用</li>
<li>模块内部数据访问</li>
<li>模块外部数据访问</li>
<li>模块外部函数调用</li>
</ul>


<p>第一种情况应该是最简单的，因为在模块内部函数与调用者的位置是相对的，可以采取相对地址调用。</p>

<p>第二种情况同样采用相对地址的访问，这里有一个trick，就是如何得到数据地址和当前地址的相对值，俞子甲的书中介绍了一种方法(7.3节)。另外，在处理共享库的全局变量的时候，编译器都把它当作定义在其它模块的全局变量，相当于后面讲的类型三，使用GOT表。</p>

<p>第三种情况就复杂一点了，因为它要等到装载时才能决定。这里就要用到GOT（Global Offset Table）表了，ELF在数据段中建立一个指向相关地址的指针数组。对于数据变量a，在GOT表中有一个4bytes的地址项与之对应，在程序装载时，链接器会找到这个变量的地址，并将该项进行修改。</p>

<p>第四种情况和第三种类似，只是地址为函数地址。</p>

<p>其实还有第五中情况，就是模块间的全局变量，比如下面这个例子：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">extern</span> <span class="kt">int</span> <span class="n">global</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">global</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>如果一个定义在共享模块内部的全局变量，编译器并不知道它是否会被其它模块使用，所以当前编译器在遇到这种全局变量的时候都会把其当做定义在其它模块中的全局变量，即上面的第三种情况，使用GOT表进行访问。</p>

<p>这里还要注意一点的是，在产生地址无关代码的时候参数-fpic和-fPIC的区别，-fpic产生的代码相对较小，而且较快，但是对于一些硬件平台有一些限制。另外，它也可以被用在可执行代码上，这时，就被称为PIE（using -fPIE or -fpie）。</p>

<p>这里需要澄清的一点是，对于一个共享库lib.so来说，它在不同的进程中都有自己独立的副本，而在同个进程不同线程中则是共享的。而对于多进程共享全局变量使用的是“共享数据段”，而多线程访问不同全局变量则被称为“线程私有存储”。</p>

<p>还有，对于数据段的绝对地址引用，可以用到装载时重定位的方法来解决，即对于共享对象来说，如果数据段中有绝对地址引用，如static int *p = &amp;a，编译器和链接器会产生一个重定位表，当动态链接器装载共享对象时若发现有重定位入口，则对其进行重定位。</p>

<h4>延迟绑定（PLT）</h4>

<p>在动态链接的程序开始运行的时候都会通过动态链接器寻找并装载共享对象，但是有些函数其实可能并不会被调用。为了增加性能，会采用一种被称为PLT（Procedure Linkage Table）的方式，它的基本思想就是当函数第一次被用到时才进行绑定。它采用了一些很精巧的指令来完成:</p>

<p>每个外部函数都有一个在PLT对应的项（bar@plt)</p>

<pre><code>bar@plt:
jmp *(bar@GOT)
push n
push moduleID
jmp _dl_runtime_resolve
</code></pre>

<p>在这里第一条指令跳转到bar在GOT中的项，该项中的初始地址即为这里第二条指令（push n）的地址，相当于没有效果，然后将bar的信息和其所在模块的信息压入栈，最后调用_dl_runtim_resolve将bar真正对的地址填入到bar@GOT中，当下次真正调用bar的时候就会跳转到真正的函数地址，并返回到调用者，而不会回到<em>push n</em>的地址了。</p>

<p>ELF将GOT分成了两个表“.got"和".got.plt", ".got"用来保存全局变量引用地址，".got.plt"用来保存函数引用的地址，在".got.plt"中前三项是有特殊意义的：</p>

<ul>
<li>第一项保存".dynamic"段的地址，这个段描述了本模块动态链接相关的信息；</li>
<li>第二项保存的是本模块的ID；</li>
<li>第三项保存的是_dl_runtime_resolve()的地址。</li>
</ul>


<p>而".got.plt"的其余项分别对应每个外部函数的引用。</p>

<h4>动态链接相关结构</h4>

<p>在动态链接的情况下，在装载完可执行文件之后，操作系统会将控制权转交给动态链接器，动态链接器的路径在".interp"下指定。</p>

<p>和动态链接相关的段比如说：</p>

<h5>.dynamic</h5>

<p>动态链接器中最重要的结构就是".dynamic"段，它就像动态链接下ELF文件的”文件头“。</p>

<h5>.dynsym</h5>

<p>".dynsym"段是为了表示模块间动态链接相关符号的导入导出关系的，当然，和".symtab"段类似，它也需要一些辅助的表，如".dynstr"动态符号字符串表，".hash"符号哈希表。</p>

<h5>动态链接重定位表</h5>

<p>"rel.dyn"和"rel.plt"相当于静态链接中的"rel.data"和"rel.text"。"rel.dyn"是对数据引用的修正，它所修正的位置即".got"以及数据段，而".rel.plt"则是对函数引用的修正，即".got.plt"段。</p>

<h4>动态链接的步骤和实现</h4>

<p>主要分为三步：</p>

<h5>动态链接器自举</h5>

<p>这里有两个条件：</p>

<ul>
<li>本身不可以依赖于其它任何共享对象</li>
<li>本身所需要的全局和静态变量的重定位工作由其本身完成——即“自举”</li>
</ul>


<h5>装载共享变量</h5>

<p>从全局符号表中开始寻找其所依赖的共享变量，即".dynamic"段中一个DT_NEEDED类型，将里面提到的所有共享对象的名字放入一个装载集合中，然后从集合中一个个读取共享变量名字，找到相对应的文件，读取里面的ELF文件头和".dynamic"段，然后将相应的代码段和数据段映射到其地址空间中，并递归地做这件事。所以当所有共享变量都被装载进来后，全局符号表里面将包含所有动态链接所需要的符号。</p>

<h4>重定向和初始化</h4>

<p>装载完成后，链接器开始重新遍历可执行文件和每个共享对象的重定向表，将其GOT/PLT中需要重定向的进行修正，然后就将控制权转交给程序的入口了。由此，动态链接也就完成了。</p>
]]></content>
  </entry>
  
</feed>
